<!doctype html>
<html>
  <head>
    <title>Centrimo</title>
    <script type="text/javascript">
      //@JSON_VAR data
      var data = {
        "version": "4.8.1",
        "revision": "caa7e0031528",
        "release": "Tue Feb  7 14:03:40 EST 2012",
        "cmd": [
          "\/lustre\/mib-cri\/carrol09\/Work\/MyPipe\/NewMeme\/bin\/centrimo",
          "-verbosity", "1", "-oc",
          "\/lustre\/mib-cri\/carrol09\/Work\/PipelinePracticeSet\/Trial\/20121114_MontoyaAR_DN_Hes6ChIP\/Peaks\/Macs\/Motif\/MCF7\/Denovo\/centrimo_out",
          "\/lustre\/mib-cri\/carrol09\/Work\/PipelinePracticeSet\/Trial\/20121114_MontoyaAR_DN_Hes6ChIP\/Peaks\/Macs\/Motif\/MCF7\/SeqUnderPeaks.fa",
          "\/lustre\/mib-cri\/carrol09\/Work\/PipelinePracticeSet\/Trial\/20121114_MontoyaAR_DN_Hes6ChIP\/Peaks\/Macs\/Motif\/MCF7\/Denovo\/meme_out\/meme.txt"
        ],
        "options": {
          "motif-pseudo": 0.1,
          "score": 5,
          "ethresh": 10,
          "maxbin": 0,
          "norc": false,
          "noflip": false
        },
        "seqlen": 200,
        "tested": 3,
        "sequence_db": {
          "source": "\/lustre\/mib-cri\/carrol09\/Work\/PipelinePracticeSet\/Trial\/20121114_MontoyaAR_DN_Hes6ChIP\/Peaks\/Macs\/Motif\/MCF7\/SeqUnderPeaks.fa",
          "count": 500
        },
        "motif_dbs": [
          {
            "source": "\/lustre\/mib-cri\/carrol09\/Work\/PipelinePracticeSet\/Trial\/20121114_MontoyaAR_DN_Hes6ChIP\/Peaks\/Macs\/Motif\/MCF7\/Denovo\/meme_out\/meme.txt",
            "count": 3
          }
        ],
        "motifs": [
          {
            "db": 0,
            "id": "1",
            "len": 30,
            "motif_evalue": 1.5e-59,
            "motif_nsites": 13,
            "pwm": [
              [0.0020345, 0.612465, 0.383442, 0.00205885], 
              [0.0020345, 0.383456, 0.00176298, 0.612746], 
              [0.460049, 0.00177725, 0.536115, 0.00205885], 
              [0.0783703, 0.00177725, 0.765122, 0.15473], 
              [0.0020345, 0.459792, 0.00176298, 0.53641], 
              [0.0020345, 0.994144, 0.00176298, 0.00205885], 
              [0.0020345, 0.00177725, 0.00176298, 0.994425], 
              [0.0020345, 0.459792, 0.0780988, 0.460074], 
              [0.154706, 0.00177725, 0.765122, 0.0783947], 
              [0.994401, 0.00177725, 0.00176298, 0.00205885], 
              [0.612722, 0.383456, 0.00176298, 0.00205885], 
              [0.0020345, 0.994144, 0.00176298, 0.00205885], 
              [0.0020345, 0.0781131, 0.00176298, 0.918089], 
              [0.0783703, 0.917808, 0.00176298, 0.00205885], 
              [0.0020345, 0.994144, 0.00176298, 0.00205885], 
              [0.0020345, 0.0781131, 0.00176298, 0.918089], 
              [0.0020345, 0.0781131, 0.917794, 0.00205885], 
              [0.536386, 0.0781131, 0.383442, 0.00205885], 
              [0.0020345, 0.230785, 0.765122, 0.00205885], 
              [0.0020345, 0.765136, 0.0780988, 0.15473], 
              [0.0020345, 0.00177725, 0.00176298, 0.994425], 
              [0.0020345, 0.841472, 0.00176298, 0.15473], 
              [0.994401, 0.00177725, 0.00176298, 0.00205885], 
              [0.765394, 0.00177725, 0.23077, 0.00205885], 
              [0.0783703, 0.00177725, 0.917794, 0.00205885], 
              [0.0020345, 0.536129, 0.00176298, 0.460074], 
              [0.154706, 0.0781131, 0.765122, 0.00205885], 
              [0.994401, 0.00177725, 0.00176298, 0.00205885], 
              [0.0020345, 0.00177725, 0.00176298, 0.994425], 
              [0.0020345, 0.917808, 0.00176298, 0.0783947]
            ],
            "bin_width": 65,
            "bin_sites": 13,
            "total_sites": 27,
            "log_pvalue": -1.27543e-07,
            "max_prob": 0.111111,
            "sites": [
              0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
              0, 0, 0, 0.5, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 0, 0, 1,
              0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
              0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
              0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0
            ]
          }, {
            "db": 0,
            "id": "2",
            "len": 30,
            "motif_evalue": 3e-59,
            "motif_nsites": 13,
            "pwm": [
              [0.0020345, 0.841472, 0.00176298, 0.15473], 
              [0.841729, 0.00177725, 0.154435, 0.00205885], 
              [0.0020345, 0.30712, 0.0780988, 0.612746], 
              [0.307378, 0.00177725, 0.688786, 0.00205885], 
              [0.0020345, 0.841472, 0.00176298, 0.15473], 
              [0.0020345, 0.917808, 0.00176298, 0.0783947], 
              [0.0020345, 0.0781131, 0.00176298, 0.918089], 
              [0.0783703, 0.00177725, 0.917794, 0.00205885], 
              [0.0020345, 0.00177725, 0.00176298, 0.994425], 
              [0.918065, 0.00177725, 0.0780988, 0.00205885], 
              [0.689058, 0.00177725, 0.307106, 0.00205885], 
              [0.0020345, 0.154449, 0.0780988, 0.765418], 
              [0.0020345, 0.841472, 0.00176298, 0.15473], 
              [0.0783703, 0.6888, 0.0780988, 0.15473], 
              [0.0020345, 0.917808, 0.00176298, 0.0783947], 
              [0.994401, 0.00177725, 0.00176298, 0.00205885], 
              [0.0783703, 0.00177725, 0.917794, 0.00205885], 
              [0.0020345, 0.917808, 0.00176298, 0.0783947], 
              [0.460049, 0.00177725, 0.00176298, 0.53641], 
              [0.383714, 0.383456, 0.154435, 0.0783947], 
              [0.0020345, 0.459792, 0.00176298, 0.53641], 
              [0.0020345, 0.00177725, 0.0780988, 0.918089], 
              [0.0020345, 0.30712, 0.00176298, 0.689082], 
              [0.383714, 0.00177725, 0.536115, 0.0783947], 
              [0.0020345, 0.00177725, 0.994129, 0.00205885], 
              [0.0783703, 0.00177725, 0.917794, 0.00205885], 
              [0.994401, 0.00177725, 0.00176298, 0.00205885], 
              [0.0020345, 0.00177725, 0.994129, 0.00205885], 
              [0.0020345, 0.00177725, 0.994129, 0.00205885], 
              [0.0020345, 0.994144, 0.00176298, 0.00205885]
            ],
            "bin_width": 161,
            "bin_sites": 29,
            "total_sites": 29,
            "log_pvalue": -3.70831e-07,
            "max_prob": 0.0689655,
            "sites": [
              0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
              0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
              1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,
              0, 0, 0
            ]
          }, {
            "db": 0,
            "id": "3",
            "len": 29,
            "motif_evalue": 2.4e-34,
            "motif_nsites": 12,
            "pwm": [
              [0.332781, 0.00192413, 0.00190868, 0.663386], 
              [0.00220264, 0.00192413, 0.084553, 0.91132], 
              [0.00220264, 0.167214, 0.00190868, 0.828675], 
              [0.00220264, 0.249858, 0.00190868, 0.746031], 
              [0.00220264, 0.0845684, 0.084553, 0.828675], 
              [0.0848469, 0.00192413, 0.332487, 0.580741], 
              [0.00220264, 0.00192413, 0.00190868, 0.993965], 
              [0.250137, 0.00192413, 0.00190868, 0.746031], 
              [0.00220264, 0.00192413, 0.167198, 0.828675], 
              [0.00220264, 0.00192413, 0.00190868, 0.993965], 
              [0.0848469, 0.00192413, 0.00190868, 0.91132], 
              [0.00220264, 0.00192413, 0.167198, 0.828675], 
              [0.00220264, 0.0845684, 0.00190868, 0.91132], 
              [0.167492, 0.00192413, 0.084553, 0.746031], 
              [0.00220264, 0.00192413, 0.332487, 0.663386], 
              [0.167492, 0.00192413, 0.084553, 0.746031], 
              [0.66336, 0.00192413, 0.00190868, 0.332807], 
              [0.250137, 0.00192413, 0.74571, 0.00222901], 
              [0.828649, 0.0845684, 0.00190868, 0.0848733], 
              [0.0848469, 0.00192413, 0.911, 0.00222901], 
              [0.911294, 0.00192413, 0.00190868, 0.0848733], 
              [0.0848469, 0.663081, 0.00190868, 0.250163], 
              [0.580715, 0.00192413, 0.415132, 0.00222901], 
              [0.00220264, 0.00192413, 0.993644, 0.00222901], 
              [0.49807, 0.00192413, 0.497776, 0.00222901], 
              [0.0848469, 0.00192413, 0.911, 0.00222901], 
              [0.00220264, 0.00192413, 0.00190868, 0.993965], 
              [0.00220264, 0.663081, 0.00190868, 0.332807], 
              [0.00220264, 0.00192413, 0.00190868, 0.993965]
            ],
            "bin_width": 156,
            "bin_sites": 25,
            "total_sites": 25,
            "log_pvalue": -0.00061049,
            "max_prob": 0.04,
            "sites": [
              0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
              0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
              0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
              0, 0, 0, 0
            ]
          }
        ]
      };
    </script>
    <script type="text/javascript">
var site_url = "http://meme.nbcr.net/meme";

    </script>
    <script type="text/javascript">
function rad2deg(rad) {
  return rad * 180 / Math.PI;
}

function parse_line_join(line_join) {
  line_join = line_join.toLowerCase();
  if (line_join == "bevel") {
    return 2;
  } else if (line_join == "round") {
    return 1;
  } else { // miter
    return 0;
  }
}

function parse_line_cap(line_cap) {
  line_cap = line_cap.toLowerCase();
  if (line_cap == "square") {
    return 2;
  } else if (line_cap == "round") {
    return 1;
  } else { // butt 
    return 0;
  }
}

function parse_text_align(text_align) {
  text_align = text_align.toLowerCase();
  if (text_align == "center") {
    return "center";
  } else if (text_align == "end" || text_align == "right") {
    return "right"; 
  } else { // start or left
    return "left";
  }
}

function parse_text_baseline(text_baseline) {
  text_baseline = text_baseline.toLowerCase();
  if (text_baseline == "top" || text_baseline == "hanging") {
    return "top";
  } else if (text_baseline == "middle") {
    return "middle";
  } else if (text_baseline == "bottom") {
    return "bottom";
  } else { // alphabetic or ideographic
    return "alphabetic";
  }
}

function parse_colour(colour) {
  var hex6_re = /^#([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/;
  var hex3_re = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/;
  var rgb_re = /^\s*rgb\s*\(\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*\)\s*$/;
  var rgba_re = /^\s*rgba\s*\(\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*\)\s*$/;
  if (colour === undefined || colour == "") {
    return {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  }
  colour = colour.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); //trim
  colour = colour.toLowerCase();
  if (colour == "maroon") {// #800000
    return {'red': 128, 'green': 0, 'blue': 0, 'alpha': 255};
  } else if (colour == "red") { // #FF0000
    return {'red': 255, 'green': 0, 'blue': 0, 'alpha': 255};
  } else if (colour == "orange") { // FFA500
    return {'red': 255, 'green': 165, 'blue': 0, 'alpha': 255};
  } else if (colour == "yellow") { // #FFFF00
    return {'red': 255, 'green': 255, 'blue': 0, 'alpha': 255};
  } else if (colour == "olive") { // #808000
    return {'red': 128, 'green': 128, 'blue': 0, 'alpha': 255};
  } else if (colour == "purple") { // #800080
    return {'red': 128, 'green': 0, 'blue': 128, 'alpha': 255};
  } else if (colour == "fuchsia") { // #FF00FF
    return {'red': 255, 'green': 0, 'blue': 255, 'alpha': 255};
  } else if (colour == "white") { // #FFFFFF
    return {'red': 255, 'green': 255, 'blue': 255, 'alpha': 255};
  } else if (colour == "lime") { // #00FF00
    return {'red': 0, 'green': 255, 'blue': 0, 'alpha': 255};
  } else if (colour == "green") { // #008000
    return {'red': 0, 'green': 128, 'blue': 0, 'alpha': 255};
  } else if (colour == "navy") { // #000080
    return {'red': 0, 'green': 0, 'blue': 128, 'alpha': 255};
  } else if (colour == "blue") { // #0000FF
    return {'red': 0, 'green': 0, 'blue': 255, 'alpha': 255};
  } else if (colour == "aqua") { // #00FFFF
    return {'red': 0, 'green': 255, 'blue': 255, 'alpha': 255};
  } else if (colour == "teal") { // #008080
    return {'red': 0, 'green': 128, 'blue': 128, 'alpha': 255};
  } else if (colour == "black") { // #000000
    return {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  } else if (colour == "silver") { // #C0C0C0
    return {'red': 192, 'green': 192, 'blue': 192, 'alpha': 255};
  } else if (colour == "gray") { // #808080
    return {'red': 128, 'green': 128, 'blue': 128, 'alpha': 255};
  }
  var matches;
  matches = hex6_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1], 16);
    var green = parseInt(matches[2], 16);
    var blue = parseInt(matches[3], 16);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': 255};
  }
  matches = hex3_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1] + matches[1], 16);
    var green = parseInt(matches[2] + matches[2], 16);
    var blue = parseInt(matches[3] + matches[3], 16);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': 255};
  }
  matches = rgb_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1]);
    if (matches[2] == "%") red = Math.round((red * 255) / 100);
    var green = parseInt(matches[3]);
    if (matches[4] == "%") green = Math.round((green * 255) / 100);
    var blue = parseInt(matches[5]);
    if (matches[6] == "%") blue = Math.round((blue * 255) / 100);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': 255};
  }
  matches = rgba_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1]);
    if (matches[2] == "%") red = Math.round((red * 255) / 100);
    var green = parseInt(matches[3]);
    if (matches[4] == "%") green = Math.round((green * 255) / 100);
    var blue = parseInt(matches[5]);
    if (matches[6] == "%") blue = Math.round((blue * 255) / 100);
    var alpha = parseInt(matches[7]);
    if (matches[8] == "%") alpha = Math.round((alpha * 255) / 100);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': alpha};
  }
  // default to black
  throw new Error("Failed to parse colour: " + colour);
}

function colour_equals(colour1, colour2) {
  if (colour1.red != colour2.red) return false;
  if (colour1.green != colour2.green) return false;
  if (colour1.blue != colour2.blue) return false;
  if (colour1.alpha != colour2.alpha) return false;
  return true;
}

// splits a font string into words
function split_words(str) {
  var words = [];
  var start = -1;
  var space = /\s/;
  var single_quote = false;
  var double_quote = false;
  // read words
  for (var i = 0; i < str.length; i++) {
    if (start == -1) {
      if (!space.test(str.charAt(i))) {
        switch (str.charAt(i)) {
          case "'":
            single_quote = true;
            start = i + 1;
            break;
          case '"':
            double_quote = true;
            start = i + 1;
            break;
          default:
            start = i;
        }
      }
    } else {
      if (!single_quote && !double_quote) {
        if (space.test(str.charAt(i))) {
          var len = i - start;
          if (len > 0) words.push(str.substr(start, len));
          start = -1;
        } else if (str.charAt(i) == "'" || str.charAt(i) == '"') {
          throw new Error("Quote in the middle of an unquoted word!");
        }
      } else if (single_quote) {
        if (str.charAt(i) == "'") {
          var len = i - start;
          if (len > 0) words.push(str.substr(start, len));
          start = -1;
          single_quote = false;
        }
      } else if (double_quote) {
        if (str.charAt(i) == '"') {
          var len = i - start;
          if (len > 0) words.push(str.substr(start, len));
          start = -1;
          double_quote = false;
        }
      }
    }
  }
  if (start != -1) {
    if (single_quote || double_quote) throw new Error("Unterminated quoted region");
    words.push(str.substr(start));
  }
  return words;
}

function add_intercepts(ctx2d, eps_callback) {
  ctx2d.eps_callback = eps_callback;
  ctx2d.save = function() {
    this.eps_callback.save();
    Object.getPrototypeOf(this).save.call(this);
  };
  ctx2d.restore = function() {
    this.eps_callback.restore();
    Object.getPrototypeOf(this).restore.call(this);
  };
  ctx2d.beginPath = function() {
    this.eps_callback.beginPath();
    Object.getPrototypeOf(this).beginPath.call(this);
  };
  ctx2d.closePath = function() {
    this.eps_callback.closePath();
    Object.getPrototypeOf(this).closePath.call(this);
  };
  ctx2d.moveTo = function(x, y) {
    this.eps_callback.moveTo(x, y);
    Object.getPrototypeOf(this).moveTo.call(this, x, y);
  };
  ctx2d.lineTo = function(x, y) {
    this.eps_callback.lineTo(x, y);
    Object.getPrototypeOf(this).lineTo.call(this, x, y);
  };
  ctx2d.rect = function(x, y, w, h) {
    this.eps_callback.rect(x, y, w, h);
    Object.getPrototypeOf(this).rect.call(this, x, y, w, h);
  };
  ctx2d.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.eps_callback.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    Object.getPrototypeOf(this).arc.call(this, x, y, radius, startAngle, endAngle, anticlockwise);
  };
  ctx2d.arcTo = function(cpx1, cpy1, cpx2, cpy2, radius) {
    this.eps_callback.arcTo(cpx1, cpy1, cpx2, cpy2, radius);
    Object.getPrototypeOf(this).arcTo.call(this, cpx1, cpy1, cpx2, cpy2, radius);
  };
  ctx2d.quadraticArcTo = function(cpx, cpy, x, y) {
    this.eps_callback.quadraticArcTo(cpx, cpy, x, y);
    Object.getPrototypeOf(this).quadraticArcTo.call(this, cpx, cpy, x, y);
  };
  ctx2d.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.eps_callback.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    Object.getPrototypeOf(this).bezierCurveTo.call(this, cp1x, cp1y, cp2x, cp2y, x, y);
  };
  ctx2d.stroke = function() {
    this.eps_callback.stroke();
    Object.getPrototypeOf(this).stroke.call(this);
  };
  ctx2d.fill = function() {
    this.eps_callback.fill();
    Object.getPrototypeOf(this).fill.call(this);
  };
  ctx2d.clip = function() {
    this.eps_callback.clip();
    Object.getPrototypeOf(this).clip.call(this);
  };
  ctx2d.fillRect = function(x, y, width, height) {
    this.eps_callback.fillRect(x, y, width, height);
    Object.getPrototypeOf(this).fillRect.call(this, x, y, width, height);
  };
  ctx2d.strokeRect = function(x, y, width, height) {
    this.eps_callback.strokeRect(x, y, width, height);
    Object.getPrototypeOf(this).strokeRect.call(this, x, y, width, height);
  };
  ctx2d.clearRect = function(x, y, width, height) {
    this.eps_callback.clearRect(x, y, width, height);
    Object.getPrototypeOf(this).clearRect.call(this, x, y, width, height);
  };
  ctx2d.fillText = function(string, x, y) {
    this.eps_callback.fillText(string, x, y);
    Object.getPrototypeOf(this).fillText.call(this, string, x, y);
  };
  ctx2d.translate = function(dx, dy) {
    this.eps_callback.translate(dx, dy);
    Object.getPrototypeOf(this).translate.call(this, dx, dy);
  };
  ctx2d.rotate = function(angle) {
    this.eps_callback.rotate(angle);
    Object.getPrototypeOf(this).rotate.call(this, angle);
  };
  ctx2d.scale = function(sx, sy) {
    this.eps_callback.scale(sx, sy);
    Object.getPrototypeOf(this).scale.call(this, sx, sy);
  };
  ctx2d.transform = function(m11, m12, m21, m22, dx, dy) {
    this.eps_callback.transform(m11, m12, m21, m22, dx, dy);
    Object.getPrototypeOf(this).transform.call(this, m11, m12, m21, m22, dx, dy);
  };
  ctx2d.setTransform = function(m11, m12, m21, m22, dx, dy) {
    this.eps_callback.setTransform(m11, m12, m21, m22, dx, dy);
    Object.getPrototypeOf(this).setTransform.call(this, m11, m12, m21, m22, dx, dy);
  };
}

var EpsState = function(copy) {
  // canvas vars
  this.activeStyle = {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  this.fillStyle = {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  this.strokeStyle = {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  this.lineWidth = 1.0;
  this.lineCap = 0;
  this.lineJoin = 0;
  this.miterLimit = 10.0;
  this.font = undefined;
  this.textAlign = "left";
  this.textBaseline = "alphabetic";
  if (copy) {
    this.activeStyle = copy.activeStyle;
    this.fillStyle = copy.fillStyle;
    this.strokeStyle = copy.strokeStyle;
    this.lineWidth = copy.lineWidth;
    this.lineCap = copy.lineCap;
    this.lineJoin = copy.lineJoin;
    this.miterLimit = copy.miterLimit;
    this.font = copy.font;
    this.textAlign = copy.textAlign;
    this.textBaseline = copy.textBaseline;
  }
};


var EpsContext = function(ctx, width, height) {
  var title = "Image Title";
  var creator = "Image Creator";
  var date = new Date();
  // private parameters
  this.ctx = ctx;
  this.width = width;
  this.height = height;
  this.stack = [];
  this.current_state = new EpsState();
  this.font_lookup = {};
  this.indent = "";
  this.eps_text = 
    "%!PS-Adobe-3.0 EPSF-3.0\n" + 
    "%%Title: " + title + "\n" + 
    "%%Creator: " + creator + "\n" +
    "%%CreationDate: " + date.toUTCString() + "\n" + 
    "%%BoundingBox: 0 0 " + (width * 0.75) + " " + (height * 0.75) + "\n" +
    "%%Pages: 0\n" +
    "%%DocumentFonts:\n" +
    "%%EndComments\n" +
    "0.75 0.75 scale\n" +
    "0 " + height + " translate\n" + 
    "1 -1 scale\n";
  add_intercepts(ctx, this);
};

// look for differences between the current state and the settings to see 
// what has changed. Apply the changes to the eps file.
EpsContext.prototype.detect = function() {
  var state = this.current_state;
  var ctx = this.ctx;
  if (ctx.lineWidth != state.lineWidth) {
    state.lineWidth = ctx.lineWidth;
    this.eps_text += this.indent + state.lineWidth + " setlinewidth\n";
  }
  var cap = parse_line_cap(ctx.lineCap);
  if (cap != state.lineCap) {
    state.lineCap = cap;
    this.eps_text += this.indent + state.lineCap + " setlinecap\n";
  }
  var join = parse_line_join(ctx.lineJoin);
  if (join != state.lineJoin) {
    state.lineJoin = join;
    this.eps_text += this.indent + state.lineJoin + " setlinejoin\n";
  }
  var miterLimit = parseInt(ctx.miterLimit);
  if (miterLimit != state.miterLimit) {
    state.miterLimit = miterLimit;
    this.eps_text += this.indent + state.miterLimit + " setmiterlimit\n";
  }
  var strokeStyle = parse_colour(ctx.strokeStyle);
  if (!colour_equals(strokeStyle, state.strokeStyle)) {
    state.strokeStyle = strokeStyle;
    this.activateStyle(false);
  }
  var fillStyle = parse_colour(ctx.fillStyle);
  if (!colour_equals(fillStyle, state.fillStyle)) {
    state.fillStyle = fillStyle;
    this.activateStyle(true);
  }
  var textAlign = parse_text_align(ctx.textAlign);
  if (textAlign != state.textAlign) {
    state.textAlign = textAlign;
  }
  var textBaseline = parse_text_baseline(ctx.textBaseline);
  if (textBaseline != state.textBaseline) {
    state.textBaseline = textBaseline;
  }
  var font = this.lookup_font(ctx.font);
  if (font !== undefined && font != state.font) {
    state.font = font;
    this.eps_text += this.indent + "/" + font.name + " findfont " +  
      font.size + " scalefont setfont\n";
  }
};

EpsContext.prototype.activateStyle = function(useFillStyle) {
  var state = this.current_state;
  var style = (useFillStyle ? state.fillStyle : state.strokeStyle);
  if (!colour_equals(state.activeStyle, style)) {
    this.eps_text += this.indent + (style.red / 255) + " " + 
      (style.green / 255) + " " + (style.blue / 255) + " setrgbcolor\n";
    state.activeStyle = style;
  }
};


// saves the current state on the stack
EpsContext.prototype.save = function() {
  this.detect();
  // gsave
  this.eps_text += this.indent + "gsave\n";
  this.stack.push(new EpsState(this.current_state));
  this.indent += "  ";
};

// restores the last saved state
EpsContext.prototype.restore = function() {
  if (this.stack.length == 0) throw new Error("Call to restore not matched with call to save.");
  this.detect();
  this.current_state = this.stack.pop();
  this.indent = Array(this.stack.length + 1).join("  ");
  // grestore
  this.eps_text += this.indent + "grestore\n";
};

// start a path
EpsContext.prototype.beginPath = function() {
  this.detect();
  // newpath
  this.eps_text += this.indent + "newpath\n";
};

// join the current position to the path start
EpsContext.prototype.closePath = function() {
  this.detect();
  // closepath
  this.eps_text += this.indent + "closepath\n";
};

// move the current position
EpsContext.prototype.moveTo = function(x, y) {
  this.detect();
  // moveto
  this.eps_text += this.indent + x + " " + y + " moveto\n";
};

// join the current position to a new position and update the current position
EpsContext.prototype.lineTo = function(x, y) {
  this.detect();
  // lineto
  this.eps_text += this.indent + x + " " + y + " lineto\n";
};

// add a rectangle to the path
EpsContext.prototype.rect = function(x, y, width, height) {
  this.moveTo(x, y);
  this.lineTo(x + width, y);
  this.lineTo(x + width, y + height);
  this.lineTo(x, y + height);
  this.closePath();
};

// add an arc to the path
EpsContext.prototype.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
  this.detect();
  if (anticlockwise) {
    // command "X Y RADIUS START_ANGLE END_ANGLE arc"
    this.eps_text += this.indent + x + " " + y + " " + radius + " " + rad2deg(startAngle) + " " + rad2deg(endAngle) + " arcn\n";
  } else {
    // command "X Y RADIUS START_ANGLE END_ANGLE arcn"
    this.eps_text += this.indent + x + " " + y + " " + radius + " " + rad2deg(startAngle) + " " + rad2deg(endAngle) + " arc\n";
  }
};

// imagine two lines, one going from the current position to point 1 and
// another going from point 1 to point 2. 
// Now imagine a circle of the given radius which touches the two lines at at 
// two tangental points T01 and T12. Add a line to the path that goes from
// the current position to T01 and add the arc which goes from T01 to T12.
// see http://www.dbp-consulting.com/tutorials/canvas/CanvasArcTo.html
EpsContext.prototype.arcTo = function(cpx1, cpy1, cpx2, cpy2, radius) {
  this.detect();
  // command "X1 Y1 X2 Y2 RADIUS arct"
  this.eps_text += this.indent + cpx1 + " " + cpy1 + " " + cpx2 + " " + cpy2 + " " + radius + " arct\n";
};

EpsContext.prototype.quadraticArcTo = function(cpx, cpy, x, y) {
  /* 
   For the equations below the following variable name prefixes are used: 
     qp0 is the quadratic curve starting point (you must keep this from your 
        last point sent to moveTo(), lineTo(), or bezierCurveTo() ). 
     qp1 is the quadratic curve control point (this is the cpx,cpy you would 
        have sent to quadraticCurveTo() ). 
     qp2 is the quadratic curve ending point (this is the x,y arguments you 
        would have sent to quadraticCurveTo() ). 
   We will convert these points to compute the two needed cubic control points 
    (the starting/ending points are the same for both 
   the quadratic and cubic curves. 
 
   The exact equations for the two cubic control points are: 
     cp0 = qp0 and cp3 = qp2 
     cp1 = qp0 + (qp1 - qp0) * ratio 
     cp2 = cp1 + (qp2 - qp0) * (1 - ratio) 
     where ratio = (sqrt(2) - 1) * 4 / 3 exactly (approx. 0.5522847498307933984022516322796) 
                   if the quadratic is an approximation of an elliptic arc, 
                      and the cubic must approximate the same arc, or 
           ratio = 2.0 / 3.0 for keeping the same quadratic curve. 
 
   In the code below, we must compute both the x and y terms for each point separately. 
 
    cp1x = qp0x + (qp1x - qp0x) * ratio; 
    cp1y = qp0y + (qp1y - qp0y) * ratio; 
    cp2x = cp1x + (qp2x - qp0x) * (1 - ratio); 
    cp2y = cp1y + (qp2y - qp0y) * (1 - ratio); 
 
   We will now  
     a) replace the qp0x and qp0y variables with currentX and currentY 
        (which *you* must store for each moveTo/lineTo/bezierCurveTo) 
     b) replace the qp1x and qp1y variables with cpx and cpy (which we would 
        have passed to quadraticCurveTo) 
     c) replace the qp2x and qp2y variables with x and y. 
   which leaves us with:  
  */  
  var ratio = 2.0 / 3.0; // 0.5522847498307933984022516322796 if the Bezier is 
                        // approximating an elliptic arc with best fitting  
  var cp1x = this.currentX + (cpx - this.currentX) * ratio;  
  var cp1y = this.currentY + (cpy - this.currentY) * ratio;  
  var cp2x = cp1x + (x - this.currentX) * (1 - ratio);  
  var cp2y = cp1y + (y - this.currentY) * (1 - ratio);  
  
  // and now call cubic Bezier curve to function   
  this.bezierCurveTo( cp1x, cp1y, cp2x, cp2y, x, y );
};

// add a bezier curve to the path
EpsContext.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
  this.detect();
  // command "CP1X CP1Y CP2X CP2Y X Y curveto"
  this.eps_text += this.indent + cp1x + " " + cp1y + " " + cp2x + " " + cp2y + " " + x + " " + y + " curveto";
};

// stroke the current path
EpsContext.prototype.stroke = function() {
  this.detect();
  this.activateStyle(false);
  // stroke
  this.eps_text += this.indent + "stroke\n";
};

// fill the current path
EpsContext.prototype.fill = function() {
  this.detect();
  this.activateStyle(true);
  // fill
  this.eps_text += this.indent + "fill\n";
};

// create a clipping region from the current path
EpsContext.prototype.clip = function() {
  this.detect();
  // clip
  this.eps_text += this.indent + "clip\n";
};

// Draws a filled rectangle
EpsContext.prototype.fillRect = function(x, y, width, height) {
  this.detect();
  this.activateStyle(true);
  // rectfill
  this.eps_text += this.indent + x + " " + y + " " + width + " " + height + " rectfill\n";
};

// Draws a rectangular outline
EpsContext.prototype.strokeRect = function(x, y, width, height) {
  this.detect();
  this.activateStyle(false);
  // rectstroke
  this.eps_text += this.indent + x + " " + y + " " + width + " " + height + " rectstroke\n";
};

// Clears the specified area and makes it transparent.
EpsContext.prototype.clearRect = function(x, y, width, height) {
  this.detect();
  // fill a rectangle with white in the cleared region
  // EPS doesn't do transparency so this is as close as it can get
  // command "1 setgray X Y WIDTH HEIGHT rectfill"
  this.eps_text += this.indent + "gsave\n";
  this.eps_text += this.indent + "  1 setgray\n";
  this.eps_text += this.indent + "  " + x + " " + y + " " + width + " " + height + " rectfill\n";
  this.eps_text += this.indent + "grestore\n";
};

// Draws a filled string
EpsContext.prototype.fillText = function(string, x, y) {
  var state = this.current_state;
  this.detect();
  this.activateStyle(true);
  // lookup the font with "/FONT_NAME findfont" (leaves FONT on stack)
  // scale the font with "FONT SIZE scalefont" (leaves FONT on stack
  // set the font with "FONT setfont"
  // move the printing location with "X Y moveto"
  // various measurement commands will be needed to do center alignment etc
  // like "stringwidth"
  // show the text with "(STRING) show"
  string = string.replace(/\\/g, "\\\\");
  string = string.replace(/\(/g, "\\(");
  string = string.replace(/\)/g, "\\)");
  this.save();
  this.translate(x, y);
  this.scale(1, -1);
  this.eps_text += this.indent + "(" + string + ")\n";
  if (state.textBaseline != "alphabetic") {
    this.beginPath();
    this.moveTo(0,0);
    this.eps_text += this.indent + "dup true charpath flattenpath pathbbox %bounding box\n";
    this.eps_text += this.indent + "/ascent exch def pop /decent exch def pop\n";
    if (state.textBaseline == "top") {
      this.eps_text += this.indent + "0 ascent neg translate %vertical align top\n";
    } else if (state.textBaseline == "middle") {
      this.eps_text += this.indent + "0 ascent decent sub 2 div decent sub neg translate %vertical align middle\n";
    } else if (state.textBaseline == "bottom") {
      this.eps_text += this.indent + "0 decent neg translate %vertical align bottom\n";
    }
  }
  if (state.textAlign == "right") {
    this.eps_text += this.indent + "dup stringwidth pop neg 0 translate %right align\n"  
  } else if (state.textAlign == "center") {
    this.eps_text += this.indent + "dup stringwidth pop 2 div neg 0 translate %center align\n"  
  }
  this.moveTo(0,0);
  this.eps_text += this.indent + "show\n";
  this.restore();
};

// move the canvas origin
EpsContext.prototype.translate = function(dx, dy) {
  this.detect();
  // command "DELTA_X DELTA_Y translate"
  this.eps_text += this.indent + dx + " " + dy + " translate\n";
};

// rotate around the canvas origin
EpsContext.prototype.rotate = function(angle) {
  this.detect();
  // command "DEGREES rotate" (note need to convert angle from radians to degrees)
  this.eps_text += this.indent + rad2deg(angle) + " rotate\n";
};

// scale 
EpsContext.prototype.scale = function(scale_x, scale_y) {
  this.detect();
  // command "SCALE_X SCALE_Y scale
  this.eps_text += this.indent + scale_x + " " + scale_y + " scale\n";
};

// multiplies the current transform matrix by the matrix described by:
// m11    m21   dx
// m12    m22   dy
// 0      0     1
EpsContext.prototype.transform = function(m11, m12, m21, m22, dx, dy) {
  this.detect();
  // command "[M11 M12 M21 M22 DX DY] concat"
  this.eps_text += this.indent + "[" + m11 + " " + m12 + " " + m21 + " " + m22 + " " + dx + " " + dy + "] concat\n";
};

// reset transform matrix to the identity matrix then call transform
EpsContext.prototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
  // command:
  // "[1 0 0 1 0 0] defaultmatrix setmatrix 0 height translate 1 -1 scale "
  // "[M11 M12 M21 M22 DX DY] concat"
  this.eps_text += this.indent + "[1 0 0 1 0 0] defaultmatrix setmatrix\n";
  this.eps_text += this.indent + "0 " + this.height + " translate\n";
  this.eps_text += this.indent + "1 -1 scale\n";
  this.transform(m11, m12, m21, m22, dx, dy);
};

EpsContext.prototype.register_font = function(font_str, eps_font, size) {
  font_str = font_str.replace(/\s+/g, ""); // remove spaces
  font_str = font_str.toLowerCase(); // lower case
  this.font_lookup[font_str] = {'name': eps_font, 'size': size};
};

EpsContext.prototype.lookup_font = function(font_str) {
  font_str = font_str.replace(/\s+/g, ""); // remove spaces
  font_str = font_str.toLowerCase(); // lower case
  return this.font_lookup[font_str];
};

// return the EPS text
EpsContext.prototype.eps = function() {
  return this.eps_text + this.indent + "showpage\n";
};

    </script>
    <script type="text/javascript">
    //======================================================================
    // start Alphabet object
    //======================================================================
    function Alphabet(alphabet, bg) {
      //variable prototype
      this.freqs = new Array();
      this.alphabet = new Array();
      this.letter_count = 0;
      //method prototype
      this.get_ic = Alphabet_get_ic;
      this.get_size = Alphabet_get_size;
      this.get_index = Alphabet_get_index;
      this.get_letter = Alphabet_get_letter;
      this.get_colour = Alphabet_get_colour;
      this.get_bg_freq = Alphabet_get_bg_freq;
      this.is_nucleotide = Alphabet_is_nucleotide;
      this.is_ambig = Alphabet_is_ambig;
      this.toString = Alphabet_to_string;
      //construct
      var is_letter = /^\w$/;
      var is_prob = /^((1(\.0+)?)|(0(\.\d+)?))$/;
      for (var pos = 0; pos < alphabet.length; pos++) {
        var letter = alphabet.charAt(pos);
        if (is_letter.test(letter)) {
          this.alphabet[this.letter_count] = letter.toUpperCase();
          this.freqs[this.letter_count] = -1;
          this.letter_count++;
        }
      }
      if (!(bg === undefined)) {
        var parts = bg.split(/\s+/);
        for (var i = 0, pos = 0; (i + 1) < parts.length; i += 2) {
          var letter = parts[i];
          var freq = parts[i+1];
          if (is_letter.test(letter) && is_prob.test(freq)) {
            letter = letter.toUpperCase();          //find the letter it matches
            for (;pos < this.letter_count; pos++) {
              if (this.alphabet[pos] == letter) break;
            }
            if (pos >= this.letter_count) throw "NOT_IN_ALPHABET";
            this.freqs[pos] = (+freq);
          }
        }
      } else {
        //assume uniform background
        var freq = 1.0 / this.letter_count;
        for (var pos = 0; pos < this.letter_count; pos++) {
          this.freqs[pos] = freq;
        }
      }
    }


    function Alphabet_get_ic() {
      if (this.is_nucleotide()) {
        return 2;
      } else {
        return Math.log(20) / Math.LN2;
      }
    }

    function Alphabet_get_size() {
      return this.letter_count;
    }

    function Alphabet_get_letter(alph_index) {
      if (alph_index < 0 || alph_index >= this.letter_count) {
        throw "BAD_ALPHABET_INDEX";
      }
      return this.alphabet[alph_index];
    }

    function Alphabet_get_bg_freq(alph_index) {
      if (alph_index < 0 || alph_index >= this.letter_count) {
        throw "BAD_ALPHABET_INDEX";
      }
      if (this.freqs[alph_index] == -1) throw "BG_FREQ_NOT_SET";
      return this.freqs[alph_index];
    }

    function Alphabet_get_colour(alph_index) {
      var red = "rgb(204,0,0)";
      var blue = "rgb(0,0,204)";
      var orange = "rgb(255,179,0)";
      var green = "rgb(0,128,0)";
      var yellow = "rgb(255,255,0)";
      var purple = "rgb(204,0,204)";
      var magenta = "rgb(255,0,255)";
      var pink = "rgb(255,204,204)";
      var turquoise = "rgb(51,230,204)";
      if (alph_index < 0 || alph_index >= this.letter_count) {
        throw "BAD_ALPHABET_INDEX";
      }
      if (this.is_nucleotide()) {
        switch (this.alphabet[alph_index]) {
          case "A":
            return red;
          case "C":
            return blue;
          case "G":
            return orange;
          case "T":
            return green;
        }
      } else {
        switch (this.alphabet[alph_index]) {
          case "A":
          case "C":
          case "F":
          case "I":
          case "L":
          case "V":
          case "W":
          case "M":
            return blue;
          case "N":
          case "Q":
          case "S":
          case "T":
            return green;
          case "D":
          case "E":
            return magenta;
          case "K":
          case "R":
            return red;
          case "H":
            return pink;
          case "G":
            return orange;
          case "P":
            return yellow;
          case "Y":
            return turquoise;
        }
      }
      return "black";
    }

    function Alphabet_is_ambig(alph_index) {
      if (alph_index < 0 || alph_index >= this.letter_count) {
        throw "BAD_ALPHABET_INDEX";
      }
      if (this.is_nucleotide()) {
        return ("ACGT".indexOf(this.alphabet[alph_index]) == -1);
      } else {
        return ("ACDEFGHIKLMNPQRSTVWY".indexOf(this.alphabet[alph_index]) == -1);
      }
    }

    function Alphabet_get_index(letter) {
      for (i = 0; i < this.letter_count; i++) {
        if (this.alphabet[i] == letter.toUpperCase()) return i;
      }
      throw "UNKNOWN_LETTER";
    }

    function Alphabet_is_nucleotide() {
      //TODO basic method, make better
      if (this.letter_count < 20) return true;
      return false;
    }

    function Alphabet_to_string() {
      return (this.is_nucleotide() ? "Nucleotide" : "Protein") + " Alphabet " + (this.alphabet.join(""));
    }

    //======================================================================
    // end Alphabet object
    //======================================================================

    //======================================================================
    // start Symbol object
    //======================================================================
    function Symbol(alph_index, scale, alphabet) {
      //variable prototype
      this.symbol = alphabet.get_letter(alph_index);
      this.scale = scale;
      this.colour = alphabet.get_colour(alph_index);
      //function prototype
      this.get_symbol = Symbol_get_symbol;
      this.get_scale = Symbol_get_scale;
      this.get_colour = Symbol_get_colour;
      this.toString = Symbol_to_string;
    }

    function Symbol_get_symbol() {
      return this.symbol;
    }

    function Symbol_get_scale() {
      return this.scale;
    }

    function Symbol_get_colour() {
      return this.colour;
    }

    function Symbol_to_string() {
      return this.symbol + " " + (Math.round(this.scale*1000)/10) + "%";
    }

    function compare_symbol(sym1, sym2) {
      if (sym1.get_scale() < sym2.get_scale()) {
        return -1;
      } else if (sym1.get_scale() > sym2.get_scale()) {
        return 1;
      } else {
        return 0;
      }
    }
    //======================================================================
    // end Symbol object
    //======================================================================

    //======================================================================
    // start Pspm object
    //======================================================================
    function Pspm(pspm, name, ltrim, rtrim, nsites, evalue) {
      if (ltrim === undefined) ltrim = 0;
      if (rtrim === undefined) rtrim = 0;
      if (nsites === undefined) nsites = 0;
      if (evalue === undefined) evalue = 0;
      //variable prototype
      this.alph_length = 0;
      this.motif_length = 0;
      this.pspm = null;
      this.name = (typeof name == "string" ? name : "");
      this.nsites = nsites;
      this.evalue = evalue;
      this.ltrim = ltrim;
      this.rtrim = rtrim;
      //function prototype
      this.copy = Pspm_copy;
      this.reverse_complement = Pspm_reverse_complement;
      this.get_stack = Pspm_get_stack;
      this.get_stack_ic = Pspm_get_stack_ic;
      this.get_motif_length = Pspm_get_motif_length;
      this.get_alph_length = Pspm_get_alph_length;
      this.get_left_trim = Pspm_get_left_trim;
      this.get_right_trim = Pspm_get_right_trim;
      this.as_pspm = Pspm_as_pspm;
      this.as_pssm = Pspm_as_pssm;
      this.toString = Pspm_to_string;
      //construct
      if (typeof pspm == "string") {
        var pspm_header = /letter-probability matrix:\s+alength=\s+(\d+)\s+w=\s+(\d+)(\s+nsites=\s+(\S+))?(\s+E=\s+(\S+))?\s*/;
        var lines = pspm.split(/\n/);
        var read_pspm = false;
        var line_num = 0;
        var col_num = 0;
        this.pspm = new Array();
        for (line_index in lines) {
          //exclude inherited properties and undefined properties
          if (!lines.hasOwnProperty(line_index) || lines[line_index] === undefined) continue;

          var line = trim(lines[line_index]);
          if (line == '') {
            continue;
          }
          if (!read_pspm) {
            var header_match = pspm_header.exec(line);
            if (header_match != null) {
              read_pspm = true;
              this.alph_length = (+header_match[1]);
              this.motif_length = (+header_match[2]);
              if (header_match[4]) this.nsites = parseFloat(header_match[4]);//not always an integer
              if (header_match[6]) this.evalue = parseFloat(header_match[6]);
              this.pspm = new Array(this.motif_length);
            }
            continue;
          }
          if (line_num >= this.motif_length) {
            throw "TOO_MANY_ROWS";
          }
          this.pspm[line_num] = new Array(this.alph_length);
          col_num = 0;
          var parts = line.split(/\s+/);
          for (part_index in parts) {
            //exclude inherited properties and undefined properties
            if (!parts.hasOwnProperty(part_index) || parts[part_index] === undefined) continue;
            
            var prob = parts[part_index];
            if (col_num >= this.alph_length) {
              throw "TOO_MANY_COLS";
            }
            this.pspm[line_num][col_num] = (+prob);
            //check the probability is within bounds
            if (this.pspm[line_num][col_num] > 1 || this.pspm[line_num][col_num] < 0) {
              throw "NUM_NOT_PROB";
            }
            col_num++;
          }
          if (col_num != this.alph_length) {
            throw "TOO_FEW_COLS";
          }
        line_num++;
        }
        if (line_num != this.motif_length) {
          throw "TOO_FEW_ROWS";
        }
      } else { 
        // assume pspm is a nested array
        this.motif_length = pspm.length;
        this.alph_length = (pspm.length > 0 ? pspm[0].length : 0);
        this.pspm = new Array(this.motif_length);
        // copy pspm and check
        for (var row = 0; row < this.motif_length; row++) {
          if (this.alph_length != pspm[row].length) throw "COLUMN_MISMATCH";
          this.pspm[row] = new Array(this.alph_length);
          var row_sum = 0;
          for (var col = 0; col < this.alph_length; col++) {
            this.pspm[row][col] = pspm[row][col];
            row_sum += this.pspm[row][col];
          }
          var delta = 0.1
          if (isNaN(row_sum) || (row_sum > 1 && (row_sum - 1) > delta) || 
              (row_sum < 1 && (1 - row_sum) > delta)) {
            throw "INVALID_SUM";
          }
        }
      }
    }

    function Clone() {}

    function Pspm_copy() {
      Clone.prototype = this;
      var clone = new Clone();
      //so far only a shallow copy, need to copy everything
      clone.alph_length = (0+this.alph_length);
      clone.motif_length = (0+this.motif_length);
      clone.name = (""+this.name);
      clone.nsites = (0+this.nsites);
      clone.evalue = (0+this.evalue);
      clone.ltrim = (0+this.ltrim);
      clone.rtrim = (0+this.rtrim);
      clone.pspm = new Array(this.motif_length);
      for (row = 0; row < this.motif_length; row++) {
        clone.pspm[row] = new Array(this.alph_length);
        for (col = 0; col < this.alph_length; col++) {
          clone.pspm[row][col] = (0+this.pspm[row][col]);
        }
      }
      return clone;
    }

    function Pspm_reverse_complement(alphabet) {
      if (this.alph_length != alphabet.get_size()) {
        throw "ALPHABET_MISMATCH";
      }
      if (!alphabet.is_nucleotide()) {
        throw "NO_PROTEIN_RC";
      }
      //reverse
      var x = 0;
      var y = this.motif_length-1;
      while (x < y) {
        var temp = this.pspm[x];
        this.pspm[x] = this.pspm[y];
        this.pspm[y] = temp;
        x++;
        y--;
      }
      //complement
      var a_index = alphabet.get_index("A");
      var c_index = alphabet.get_index("C");
      var g_index = alphabet.get_index("G");
      var t_index = alphabet.get_index("T");
      for (i = 0; i < this.motif_length; i++) {
        var row = this.pspm[i];
        //swap A and T
        var temp = row[a_index];
        row[a_index] = row[t_index];
        row[t_index] = temp;
        //swap C and G
        temp = row[c_index];
        row[c_index] = row[g_index];
        row[g_index] = temp;
      }
      //swap triming
      var temp_trim = this.ltrim;
      this.ltrim = this.rtrim;
      this.rtrim = temp_trim;
      //note that ambigs are ignored because they don't effect motifs
      return this; //allow function chaining...
    }

    function Pspm_get_stack(position, alphabet) {
      if (this.alph_length != alphabet.get_size()) {
        throw "ALPHABET_MISMATCH";
      }
      var row = this.pspm[position];
      var stack_ic = this.get_stack_ic(position, alphabet);
      var alphabet_ic = alphabet.get_ic();
      var stack = new Array();
      for (i = 0; i < this.alph_length; i++) {
        if (alphabet.is_ambig(i)) continue;
        var sym = new Symbol(i, row[i]*stack_ic/alphabet_ic, alphabet);
        if (sym.get_scale() <= 0) continue;
        stack.push(sym);
      }
      stack.sort(compare_symbol);
      return stack;
    }

    function Pspm_get_stack_ic(position, alphabet) {
      if (this.alph_length != alphabet.get_size()) {
        throw "ALPHABET_MISMATCH";
      }
      var row = this.pspm[position];
      var H = 0;
      for (var i = 0; i < this.alph_length; i++) {
        if (alphabet.is_ambig(i)) continue;
        if (row[i] == 0) continue;
        H -= (row[i] * (Math.log(row[i]) / Math.LN2));
      }
      return alphabet.get_ic() - H;
    }

    function Pspm_get_error(alphabet) {
      var asize;
      if (this.nsites == 0) return 0;
      if (alphabet.is_nucleotide()) {
        asize = 4;
      } else {
        asize = 20;
      }
      return (asize-1) / (2 * Math.log(2)*this.nsites);
    }

    function Pspm_get_motif_length() {
      return this.motif_length;
    }

    function Pspm_get_alph_length() {
      return this.alph_length;
    }

    function Pspm_get_left_trim() {
      return this.ltrim;
    }

    function Pspm_get_right_trim() {
      return this.rtrim;
    }

    function Pspm_as_pspm() {
      var out = "letter-probability matrix: alength= " + this.alph_length + 
          " w= " + this.motif_length + " nsites= " + this.nsites + 
          " E= " + this.evalue.toExponential() + "\n";
      for (var row = 0; row < this.motif_length; row++) {
        for (var col = 0; col < this.alph_length; col++) {
          if (col != 0) out += " ";
          out += this.pspm[row][col].toFixed(6);
        }
        out += "\n";
      }
      return out;
    }

    function Pspm_as_pssm(alphabet, pseudo) {
      if (typeof pseudo != "number") pseudo = 0.1;
      var out = "log-odds matrix: alength= " + this.alph_length + 
          " w= " + this.motif_length + 
          " E= " + this.evalue.toExponential() + "\n";
      var log2 = Math.log(2);
      var total = this.nsites + pseudo;
      for (var row = 0; row < this.motif_length; row++) {
        for (var col = 0; col < this.alph_length; col++) {
          if (col != 0) out += " ";
          var p = this.pspm[row][col];
          // to avoid log of zero we add a pseudo count
          var bg = alphabet.get_bg_freq(col);
          var p2 = (p * this.nsites + bg * pseudo) / total;
          // now calculate the score
          var score = -10000;
          if (p2 > 0) {
            score = Math.round((Math.log(p2 / bg) / log2) * 100)
          }
          out += score;
        }
        out += "\n";
      }
      return out;
    }

    function Pspm_to_string() {
      var str = "";
      for (row_index in this.pspm) {
        //exclude inherited properties and undefined properties
        if (!this.pspm.hasOwnProperty(row_index) || this.pspm[row_index] === undefined) continue;
        
        var row = this.pspm[row_index];
        str += row.join("\t") + "\n";
      }
      return str;
    }
    //======================================================================
    // end Pspm object
    //======================================================================
    
    //======================================================================
    // start Logo object
    //======================================================================
    function Logo(alphabet, fine_text) {
      this.alphabet = alphabet;
      this.fine_text = fine_text;
      this.pspm_list = [];
      this.pspm_column = [];
      this.rows = 0;
      this.columns = 0;

      //functions
      this.add_pspm = Logo_add_pspm;
      this.get_columns = Logo_get_columns;
      this.get_rows = Logo_get_rows;
      this.get_pspm = Logo_get_pspm;
      this.get_offset = Logo_get_offset;
    }

    function Logo_add_pspm(pspm, column) {
      if (column === undefined) column = 0;
      else if (column < 0) throw "COLUMN_OUT_OF_BOUNDS";
      this.pspm_list[this.rows] = pspm;
      this.pspm_column[this.rows] = column;
      this.rows++;
      var col = column + pspm.get_motif_length();
      if (col > this.columns) this.columns = col;
    }

    function Logo_get_columns() {
      return this.columns;
    }

    function Logo_get_rows() {
      return this.rows;
    }

    function Logo_get_pspm(row_index) {
      if (row_index < 0 || row_index >= this.rows) throw "INDEX_OUT_OF_BOUNDS";
      return this.pspm_list[row_index];
    }

    function Logo_get_offset(row_index) {
      if (row_index < 0 || row_index >= this.rows) throw "INDEX_OUT_OF_BOUNDS";
      return this.pspm_column[row_index];
    }

    //======================================================================
    // end Logo object
    //======================================================================

    //======================================================================
    // start RasterizedAlphabet
    //======================================================================

    // Rasterize Alphabet
    // 1) Measure width of text at default font for all symbols in alphabet
    // 2) sort in width ascending
    // 3) Drop the top and bottom 10% (designed to ignore outliers like 'W' and 'I')
    // 4) Calculate the average as the maximum scaling factor (designed to stop I becoming a rectangular blob).
    // 5) Assume scale of zero would result in width of zero, interpolate scale required to make perfect width font
    // 6) Draw text onto temp canvas at calculated scale
    // 7) Find bounds of drawn text
    // 8) Paint on to another canvas at the desired height (but only scaling width to fit if larger).
    function RasterizedAlphabet(alphabet, font, target_width) {
      //variable prototypes
      this.lookup = []; //a map of letter to index
      this.rasters = []; //a list of rasters
      this.dimensions = []; //a list of dimensions

      //function prototypes
      this.draw = RasterizedAlphabet_draw;

      //construct
      var default_size = 60; // size of square to assume as the default width
      var safety_pad = 20; // pixels to pad around so we don't miss the edges
      // create a canvas to do our rasterizing on
      var canvas = document.createElement("canvas");
      // assume the default font would fit in a canvas of 100 by 100
      canvas.width = default_size + 2 * safety_pad;
      canvas.height = default_size + 2 * safety_pad;
      // check for canvas support before attempting anything
      if (!canvas.getContext) throw "NO_CANVAS_SUPPORT";
      var ctx = canvas.getContext('2d');
      // check for html5 text drawing support
      if (!supports_text(ctx)) throw "NO_CANVAS_TEXT_SUPPORT";
      // calculate the middle
      var middle = Math.round(canvas.width / 2);
      // calculate the baseline
      var baseline = Math.round(canvas.height - safety_pad);
      // list of widths
      var widths = [];
      var count = 0;
      var letters = [];
      //now measure each letter in the alphabet
      for (var i = 0; i < alphabet.get_size(); ++i) {
        if (alphabet.is_ambig(i)) continue; //skip ambigs as they're never rendered
        var letter = alphabet.get_letter(i);
        letters.push(letter);
        var pos = count++;
        this.lookup[letter] = pos;
        //clear the canvas
        canvas.width = canvas.width;
        // get the context and prepare to draw our width test
        var ctx = canvas.getContext('2d');
        ctx.font = font;
        ctx.fillStyle = alphabet.get_colour(i);
        ctx.textAlign = "center";
        ctx.translate(middle, baseline);
        // draw the test text
        ctx.fillText(letter, 0, 0);
        //measure
        var size = RasterizedAlphabet_measure(ctx, canvas.width, canvas.height);
        if (size.width == 0) throw "INVISIBLE_LETTER"; //maybe the fill was white on white?
        widths.push(size.width);
        this.dimensions[pos] = size;
      }
      //sort the widths
      widths.sort(function(a,b) {return a - b;});
      //drop 10% of the items off each end
      var tenpercent = Math.floor(widths.length / 10);
      for (var i = 0; i < tenpercent; ++i) {
        widths.pop();
        widths.shift();
      }
      //calculate average width
      var avg_width = 0;
      for (var i = 0; i < widths.length; ++i) avg_width += widths[i];
      avg_width /= widths.length;
      // calculate scales
      for (var i = 0; i < this.dimensions.length; ++i) {
        var size = this.dimensions[i];
        // calculate scale
        var scale = target_width / Math.max(avg_width, size.width);
        // estimate scaled height
        var target_height = size.height * scale;
        // create an approprately sized canvas
        var raster = document.createElement("canvas");
        raster.width = target_width; // if it goes over the edge too bad...
        raster.height = target_height + safety_pad * 2;
        // calculate the middle
        middle = Math.round(raster.width / 2);
        // calculate the baseline
        baseline = Math.round(raster.height - safety_pad);
        // get the context and prepare to draw the rasterized text
        ctx = raster.getContext('2d');
        ctx.font = font;
        ctx.fillStyle = alphabet.get_colour(i);
        ctx.textAlign = "center";
        ctx.translate(middle, baseline);
        ctx.save();
        ctx.scale(scale, scale);
        // draw the rasterized text
        ctx.fillText(letters[i], 0, 0);
        ctx.restore();
        this.rasters[i] = raster;
        this.dimensions[i] = RasterizedAlphabet_measure(ctx, raster.width, raster.height);
      }
    }

    function RasterizedAlphabet_measure(ctx, cwidth, cheight) {
      var data = ctx.getImageData(0, 0, cwidth, cheight).data;
      var r = 0, c = 0;// r: row, c: column
      var top_line = -1, bottom_line = -1, left_line = -1, right_line = -1;
      var txt_width = 0, txt_height = 0;
      // Find the top-most line with a non-white pixel
      for (r = 0; r < cheight; r++) {
        for (c = 0; c < cwidth; c++) {
          if (data[r * cwidth * 4 + c * 4 + 3]) {
            top_line = r;
            break;
          }
        }
        if (top_line != -1) break;
      }
      
      //find the last line with a non-white pixel
      if (top_line != -1) {
        for (r = cheight-1; r >= top_line; r--) {
          for(c = 0; c < cwidth; c++) {
            if(data[r * cwidth * 4 + c * 4 + 3]) {
              bottom_line = r;
              break;
            }
          }
          if (bottom_line != -1) break;
        }
        txt_height = bottom_line - top_line + 1;
      }

      // Find the left-most line with a non-white pixel
      for (c = 0; c < cwidth; c++) {
        for (r = 0; r < cheight; r++) {
          if (data[r * cwidth * 4 + c * 4 + 3]) {
            left_line = c;
            break;
          }
        }
        if (left_line != -1) break;
      }

      //find the right most line with a non-white pixel
      if (left_line != -1) {
        for (c = cwidth-1; c >= left_line; c--) {
          for(r = 0; r < cheight; r++) {
            if(data[r * cwidth * 4 + c * 4 + 3]) {
              right_line = c;
              break;
            }
          }
          if (right_line != -1) break;
        }
        txt_width = right_line - left_line + 1;
      }

      //return the bounds
      return {bound_top: top_line, bound_bottom: bottom_line, bound_left: left_line, bound_right: right_line, width: txt_width, height: txt_height};
    }

    function RasterizedAlphabet_draw(ctx, letter, dx, dy, dWidth, dHeight) {
      var index = this.lookup[letter];
      var raster = this.rasters[index];
      var size = this.dimensions[index];
      ctx.drawImage(raster, 0, size.bound_top -1, raster.width, size.height+1, dx, dy, dWidth, dHeight);
    }

    //======================================================================
    // end RasterizedAlphabet
    //======================================================================

    //======================================================================
    // start LogoMetrics object
    //======================================================================

    function LogoMetrics(ctx, canvas_width, canvas_height, logo_columns, logo_rows, allow_space_for_names) {
      if (allow_space_for_names === undefined) allow_space_for_names = false;
      //variable prototypes
      this.canvas_width = canvas_width;
      this.canvas_height = canvas_height;
      this.scale_x = 1;
      this.scale_y = 1;
      this.pad_top = 5;
      this.pad_left = 10;
      this.pad_right = 5;
      this.pad_bottom = 0;
      this.pad_middle = 20;
      this.name_height = 14;
      this.name_font = "bold " + this.name_height + "px Times, sans-serif";
      this.name_spacer = 0;
      this.y_label = "bits"
      this.y_label_height = 12;
      this.y_label_font = "bold " + this.y_label_height + "px Helvetica, sans-serif";
      this.y_label_spacer = 3;
      this.y_num_height = 12;
      this.y_num_width = 0;
      this.y_num_font = "bold " + this.y_num_height + "px Helvetica, sans-serif";
      this.y_tic_width = 5;
      this.stack_pad_left = 0;
      this.stack_font = "bold 25px Helvetica, sans-serif";
      this.stack_height = 90;
      this.stack_width = 26;
      this.stacks_pad_right = 5;
      this.x_num_above = 2;
      this.x_num_height = 12;
      this.x_num_width = 0;
      this.x_num_font = "bold " + this.x_num_height + "px Helvetica, sans-serif";
      this.fine_txt_height = 6;
      this.fine_txt_above = 2;
      this.fine_txt_font = "normal " + this.fine_txt_height + "px Helvetica, sans-serif";
      this.letter_metrics = new Array();
      this.summed_width = 0;
      this.summed_height = 0;
      //function prototypes
      //none
      //calculate the width of the y axis numbers
      ctx.font = this.y_num_font;
      for (var i = 0; i <= 2; i++) {
        this.y_num_width = Math.max(this.y_num_width, ctx.measureText("" + i).width);
      }
      //calculate the width of the x axis numbers (but they are rotated so it becomes height)
      ctx.font = this.x_num_font;
      for (var i = 1; i <= logo_columns; i++) {
        this.x_num_width = Math.max(this.x_num_width, ctx.measureText("" + i).width);
      }
      
      //calculate how much vertical space we want to draw this
      //first we add the padding at the top and bottom since that's always there
      this.summed_height += this.pad_top + this.pad_bottom;
      //all except the last row have the same amount of space allocated to them
      if (logo_rows > 1) {
        var row_height = this.stack_height + this.pad_middle;
        if (allow_space_for_names) {
          row_height += this.name_height;
          //the label is allowed to overlap into the spacer
          row_height += Math.max(this.y_num_height/2, this.name_spacer); 
          //the label is allowed to overlap the space used by the other label
          row_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above); 
        } else {
          row_height += this.y_num_height/2; 
          //the label is allowed to overlap the space used by the other label
          row_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above); 
        }
        this.summed_height += row_height * (logo_rows - 1);
      }
      //the last row has the name and fine text below it but no padding
      this.summed_height += this.stack_height + this.y_num_height/2;
      if (allow_space_for_names) {
        this.summed_height += this.fine_txt_height + this.fine_txt_above + this.name_height;
        this.summed_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above + this.name_spacer);
      } else {
        this.summed_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above + this.fine_txt_height + this.fine_txt_above);
      }

      //calculate how much horizontal space we want to draw this
      //first add the padding at the left and right since that's always there
      this.summed_width += this.pad_left + this.pad_right;
      //add on the space for the y-axis label
      this.summed_width += this.y_label_height + this.y_label_spacer;
      //add on the space for the y-axis
      this.summed_width += this.y_num_width + this.y_tic_width;
      //add on the space for the stacks
      this.summed_width += (this.stack_pad_left + this.stack_width) * logo_columns;
      //add on the padding after the stacks (an offset from the fine text)
      this.summed_width += this.stacks_pad_right;

      //calculate scaling factors
      this.scale_y = this.canvas_height / this.summed_height;
      this.scale_x = this.canvas_width / this.summed_width;

      //maintain aspect ratio
      if (this.scale_y > this.scale_x) {
        this.scale_y = this.scale_x;
      } else {
        this.scale_x = this.scale_y;
      }


    }

    //======================================================================
    // end LogoMetrics object
    //======================================================================


    //found this trick at http://talideon.com/weblog/2005/02/detecting-broken-images-js.cfm
    function image_ok(img) {
      // During the onload event, IE correctly identifies any images that
      // weren't downloaded as not complete. Others should too. Gecko-based
      // browsers act like NS4 in that they report this incorrectly.
      if (!img.complete) {
        return false;
      }
      // However, they do have two very useful properties: naturalWidth and
      // naturalHeight. These give the true size of the image. If it failed
      // to load, either of these should be zero.
      if (typeof img.naturalWidth != "undefined" && img.naturalWidth == 0) {
        return false;
      }
      // No other way of checking: assume it's ok.
      return true;
    }
      
    function supports_text(ctx) {
      if (!ctx.fillText) return false;
      if (!ctx.measureText) return false;
      return true;
    }

    //draws the scale, returns the width
    function draw_scale(ctx, metrics, alphabet_ic) {
      var tic_height = metrics.stack_height / alphabet_ic;
      ctx.save();
      ctx.lineWidth = 1.5;
      ctx.translate(metrics.y_label_height, metrics.y_num_height/2);
      //draw the axis label
      ctx.save();
      ctx.font = metrics.y_label_font;
      ctx.translate(0, metrics.stack_height/2);
      ctx.save();
      ctx.rotate(-(Math.PI / 2));
      ctx.textAlign = "center";
      ctx.fillText("bits", 0, 0);
      ctx.restore();
      ctx.restore();

      ctx.translate(metrics.y_label_spacer + metrics.y_num_width, 0);

      //draw the axis tics
      ctx.save();
      ctx.translate(0, metrics.stack_height);
      ctx.font = metrics.y_num_font;
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for (var i = 0; i <= alphabet_ic; i++) {
        //draw the number
        ctx.fillText("" + i, 0, 0);
        //draw the tic
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(metrics.y_tic_width, 0);
        ctx.stroke();
        //prepare for next tic
        ctx.translate(0, -tic_height);
      }
      ctx.restore();

      ctx.translate(metrics.y_tic_width, 0);

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, metrics.stack_height);
      ctx.stroke();

      ctx.restore();
    }

    function draw_stack_num(ctx, metrics, row_index) {
      ctx.save();
      ctx.font = metrics.x_num_font;
      ctx.translate(metrics.stack_width / 2, metrics.stack_height + metrics.x_num_above);
      ctx.save();
      ctx.rotate(-(Math.PI / 2));
      ctx.textBaseline = "middle"
      ctx.textAlign = "right"
      ctx.fillText("" + (row_index + 1), 0, 0);
      ctx.restore();
      ctx.restore();
    }

    function draw_stack(ctx, metrics, symbols, raster) {
      var preferred_pad = 0;
      var sym_min = 5;

      ctx.save();//1
      ctx.translate(0, metrics.stack_height);
      for (var i in symbols) {
        //exclude inherited properties and undefined properties
        if (!symbols.hasOwnProperty(i) || symbols[i] === undefined) continue;
        
        var sym = symbols[i];
        var sym_height = metrics.stack_height * sym.get_scale();
        
        var pad = preferred_pad;
        if (sym_height - pad < sym_min) {
          pad = Math.min(pad, Math.max(0, sym_height - sym_min));
        }
        sym_height -= pad;

        //translate to the correct position
        ctx.translate(0, -(pad/2 + sym_height));
        //draw
        raster.draw(ctx, sym.get_symbol(), 0, 0, metrics.stack_width, sym_height);
        //translate past the padding
        ctx.translate(0, -(pad/2));
      }
      ctx.restore();//1
    }

    //draws a stack of symbols
    function draw_stack_old(ctx, metrics, symbols) {
      var lpad = 2;
      var sym_min = 5;
      var pos = metrics.stack_height;
      for (var i in symbols) {
        //exclude inherited properties and undefined properties
        if (!symbols.hasOwnProperty(i) || symbols[i] === undefined) continue;
        
        var sym = symbols[i];
        var sym_height = metrics.stack_height*sym.get_scale();
        var letter = metrics.get_letter_metrics(sym.get_symbol());
        //attempting to draw something smaller than a pixel causes display corruption
        if (sym_height >= 1) {
          //it's better to see the letter than to pad it
          var pad = lpad;
          if (sym_height - pad < sym_min) {
            pad = Math.min(pad, Math.max(0, sym_height - sym_min));
          }
          //move to the correct drawing position
          ctx.save();//s1
          ctx.translate(0, pos);
          //create a clipping rectangle to ensure the letter doesn't overlap when it's distorted
          ctx.save();//s2
          //ctx.beginPath(); //disabled clipping because after the improvements in the text metrics it looks better without
          //ctx.moveTo(-metrics.stack_width/2,0);
          //ctx.lineTo(metrics.stack_width/2, 0);
          //ctx.lineTo(metrics.stack_width/2, -sym_height);
          //ctx.lineTo(-metrics.stack_width/2, -sym_height);
          //ctx.lineTo(-metrics.stack_width/2,0);
          //ctx.clip();
          //now draw
          ctx.translate(0, -(pad/2));
          ctx.translate(0, -letter.get_descent(sym_height - pad));
          ctx.fillStyle = sym.get_colour();
          ctx.textAlign = "center";
          ctx.save();//s3
          ctx.scale(letter.wscale, letter.get_hscale(sym_height - pad));
          ctx.fillText(sym.get_symbol(), 0, 0);
          ctx.restore();//s3

          ctx.restore();//s2
          ctx.restore();//s1
        }

        pos = pos - sym_height;
      }
    }
    
    function draw_dashed_line(ctx, pattern, start, x1, y1, x2, y2) {
        var x, y, len, i;
        var dx = x2 - x1;
        var dy = y2 - y1;
        var tlen = Math.pow(dx*dx + dy*dy, 0.5);
        var theta = Math.atan2(dy,dx);
        var mulx = Math.cos(theta);
        var muly = Math.sin(theta);
        var lx = [];
        var ly = [];
        for (i = 0; i < pattern; ++i) {
          lx.push(pattern[i] * mulx);
          ly.push(pattern[i] * muly);
        }
        i = start;
        x = x1;
        y = y1;
        len = 0;
        ctx.beginPath();
        while (len + pattern[i] < tlen) {
          ctx.moveTo(x, y);
          x += lx[i];
          y += ly[i];
          ctx.lineTo(x, y);
          len += pattern[i];
          i = (i + 1) % pattern.length;
          x += lx[i];
          y += ly[i];
          len += pattern[i];
          i = (i + 1) % pattern.length;
        }
        if (len < tlen) {
          ctx.moveTo(x, y);
          x += mulx * (tlen - len);
          y += muly * (tlen - len);
          ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    function draw_trim_background(ctx, metrics, pspm, offset) {
      var lwidth = metrics.stack_width * pspm.get_left_trim();
      var rwidth = metrics.stack_width * pspm.get_right_trim();
      var mwidth = metrics.stack_width * pspm.get_motif_length();
      var rstart = mwidth - rwidth;
      ctx.save();//s8
      ctx.translate(offset * metrics.stack_width, 0);
      ctx.fillStyle = "rgb(240, 240, 240)";
      if (pspm.get_left_trim() > 0) ctx.fillRect(0, 0, lwidth, metrics.stack_height);
      if (pspm.get_right_trim() > 0) ctx.fillRect(rstart, 0, rwidth, metrics.stack_height);
      ctx.fillStyle = "rgb(51, 51, 51)";
      if (pspm.get_left_trim() > 0) draw_dashed_line(ctx, [3], 0, lwidth-0.5, 0, lwidth-0.5,  metrics.stack_height);
      if (pspm.get_right_trim() > 0) draw_dashed_line(ctx, [3], 0, rstart+0.5, 0, rstart+0.5,  metrics.stack_height);
      ctx.restore();//s8
    }

    function draw_logo_on_canvas(logo, canvas, show_names, scale) {
      var draw_name = (typeof show_names == "boolean" ? show_names : (logo.get_rows() > 1));
      var cwidth = canvas.width;
      var cheight = canvas.height;
      //need a minimum 46 x 120 canvas to draw the font size checks on
      if (canvas.width < 46) canvas.width = 46;
      if (canvas.height < 120) canvas.height = 120;
      var ctx = canvas.getContext('2d');
      //assume that the user wants the canvas scaled equally so calculate what the best width for this image should be
      var metrics = new LogoMetrics(ctx, canvas.width, canvas.height, logo.get_columns(), logo.get_rows(), draw_name);
      ctx.save();//s1
      if (typeof scale == "number") {
        //resize the canvas to fit the scaled logo
        cwidth = metrics.summed_width * scale;
        cheight = metrics.summed_height * scale;
      } else {
        if (cwidth == 0 && cheight == 0) {
          throw "CANVAS_MUST_HAVE_DIMENSIONS";
        } else if (cwidth == 0) {
          scale = cheight / metrics.summed_height;
          cwidth = metrics.summed_width * scale;
        } else if (cheight == 0) {
          scale = cwidth / metrics.summed_width;
          cheight = metrics.summed_height * scale;
        } else {
          scale = Math.min(cwidth / metrics.summed_width, cheight / metrics.summed_height);
        }
      }
      var raster = new RasterizedAlphabet(logo.alphabet, metrics.stack_font, metrics.stack_width * scale * 2);
      if (cwidth != canvas.width || cheight != canvas.height) {
        canvas.width = cwidth;
        canvas.height = cheight;
        //as the canvas has been resized the context is now out of date
        ctx = canvas.getContext('2d');
      }
      ctx.scale(scale, scale);
      ctx.save();//s2
      ctx.save();//s7
      //create margin
      ctx.translate(metrics.pad_left, metrics.pad_top);
      for (var pspm_i = 0; pspm_i < logo.get_rows(); ++pspm_i) {
        var pspm = logo.get_pspm(pspm_i);
        var offset = logo.get_offset(pspm_i);
        //optionally draw name if this isn't the last row or is the only row 
        if (draw_name && (logo.get_rows() == 1 || pspm_i != (logo.get_rows()-1))) {
          ctx.save();//s4
          ctx.translate(metrics.summed_width/2, metrics.name_height);
          ctx.font = metrics.name_font;
          ctx.textAlign = "center";
          ctx.fillText(pspm.name, 0, 0);
          ctx.restore();//s4
          ctx.translate(0, metrics.name_height + Math.min(0, metrics.name_spacer - metrics.y_num_height/2));
        }
        //draw scale
        draw_scale(ctx, metrics, logo.alphabet.get_ic());
        ctx.save();//s5
        //translate across past the scale
        ctx.translate(metrics.y_label_height + metrics.y_label_spacer + 
            metrics.y_num_width + metrics.y_tic_width, 0);
        //draw the trimming background
        if (pspm.get_left_trim() > 0 || pspm.get_right_trim() > 0) {
          draw_trim_background(ctx, metrics, pspm, offset);
        }
        //draw letters
        ctx.translate(0, metrics.y_num_height / 2);
        for (var col_index = 0; col_index < logo.get_columns(); col_index++) {
          ctx.translate(metrics.stack_pad_left,0);
          if (col_index >= offset && col_index < (offset + pspm.get_motif_length())) {
            var motif_position = col_index - offset;
            draw_stack_num(ctx, metrics, motif_position);
            draw_stack(ctx, metrics, pspm.get_stack(motif_position, logo.alphabet), raster);
          }
          ctx.translate(metrics.stack_width, 0);
        }
        ctx.restore();//s5
        ////optionally draw name if this is the last row but isn't the only row 
        if (draw_name && (logo.get_rows() != 1 && pspm_i == (logo.get_rows()-1))) {
          //translate vertically past the stack and axis's        
          ctx.translate(0, metrics.y_num_height/2 + metrics.stack_height + 
              Math.max(metrics.y_num_height/2, metrics.x_num_above + metrics.x_num_width + metrics.name_spacer));

          ctx.save();//s6
          ctx.translate(metrics.summed_width/2, metrics.name_height);
          ctx.font = metrics.name_font;
          ctx.textAlign = "center";
          ctx.fillText(pspm.name, 0, 0);
          ctx.restore();//s6
          ctx.translate(0, metrics.name_height);
        } else {
          //translate vertically past the stack and axis's        
          ctx.translate(0, metrics.y_num_height/2 + metrics.stack_height + Math.max(metrics.y_num_height/2, metrics.x_num_above + metrics.x_num_width));
        }
        //if not the last row then add middle padding
        if (pspm_i != (logo.get_rows() -1)) {
          ctx.translate(0, metrics.pad_middle);
        }
      }
      ctx.restore();//s7
      ctx.translate(metrics.summed_width - metrics.pad_right, metrics.summed_height - metrics.pad_bottom);
      ctx.font = metrics.fine_txt_font;
      ctx.textAlign = "right";
      ctx.fillText(logo.fine_text, 0,0);
      ctx.restore();//s2
      ctx.restore();//s1
    }

    function create_canvas(c_width, c_height, c_id, c_title, c_display) {
      var canvas = document.createElement("canvas");
      //check for canvas support before attempting anything
      if (!canvas.getContext) return null;
      var ctx = canvas.getContext('2d');
      //check for html5 text drawing support
      if (!supports_text(ctx)) return null;
      //size the canvas
      canvas.width = c_width;
      canvas.height = c_height;
      canvas.id = c_id;
      canvas.title = c_title;
      canvas.style.display = c_display;
      return canvas;
    }

    function logo_1(alphabet, fine_text, pspm) {
      var logo = new Logo(alphabet, fine_text);
      logo.add_pspm(pspm);
      return logo;
    }
    
    function logo_2(alphabet, fine_text, target, query, query_offset) {
      var logo = new Logo(alphabet, fine_text);
      if (query_offset < 0) {
        logo.add_pspm(target, -query_offset);
        logo.add_pspm(query);
      } else {
        logo.add_pspm(target);
        logo.add_pspm(query, query_offset);
      }      
      return logo;
    }

    /*
     * Specifies an alternate source for an image.
     * If the image with the image_id specified has
     * not loaded then a generated logo will be used 
     * to replace it.
     *
     * Note that the image must either have dimensions
     * or a scale must be set.
     */
    function alternate_logo(logo, image_id, scale) {
      var image = document.getElementById(image_id);
      if (!image) {
        alert("Can't find specified image id (" +  image_id + ")");
        return;
      }
      //if the image has loaded then there is no reason to use the canvas
      if (image_ok(image)) return;
      //the image has failed to load so replace it with a canvas if we can.
      var canvas = create_canvas(image.width, image.height, image_id, image.title, image.style.display);
      if (canvas == null) return;
      //draw the logo on the canvas
      draw_logo_on_canvas(logo, canvas, undefined, scale);
      //replace the image with the canvas
      image.parentNode.replaceChild(canvas, image);
    }

    /*
     * Specifes that the element with the specified id
     * should be replaced with a generated logo.
     */
    function replace_logo(logo, replace_id, scale, title_txt, display_style) {
      var element = document.getElementById(replace_id);
      if (!replace_id) {
        alert("Can't find specified id (" + replace_id + ")");
        return;
      }
      //found the element!
      var canvas = create_canvas(50, 120, replace_id, title_txt, display_style);
      if (canvas == null) return;
      //draw the logo on the canvas
      draw_logo_on_canvas(logo, canvas, undefined, scale);
      //replace the element with the canvas
      element.parentNode.replaceChild(canvas, element);
    }

    /*
     * Fast string trimming implementation found at
     * http://blog.stevenlevithan.com/archives/faster-trim-javascript
     *
     * Note that regex is good at removing leading space but
     * bad at removing trailing space as it has to first go through
     * the whole string.
     */
    function trim (str) {
      str = str.replace(/^\s\s*/, '');
      var ws = /\s/, i = str.length;
      while (ws.test(str.charAt(--i)));
      return str.slice(0, i + 1);
    }

    </script>
    <script type="text/javascript">
var palate = ["white", "cyan", "blue", "#FF00FF", "#00FF00", "red", "orange", "#008000", "#8A2BE2", "black"];
var text_palate = ["black", "black", "white", "white", "black", "white", "black", "white", "white", "white"];
var INT_MAX = 9007199254740992;

var MPG = {
  legend_font: "Helvetica",
  legend_line: 16,
  legend_pad: 5
};

var motif_db_name = [];
var s_motifs = [];
var s_swatches = [];
var s_logos = []
var swap = null;
var dna_alphabet = new Alphabet("ACGT", "A 0.25 C 0.25 G 0.25 T 0.25");
var logo_timer = null; // timer to draw motif when the mouse pauses on a row
var logo_motif = null; // motif to draw when timer expires
//var legend_x = 0;
//var legend_y = 0;
var legend_x = 1000;
var legend_y = 1000;
var legend_width = 10;
var legend_height = 10;

pre_load_setup();


/*
 * name_from_source
 *
 * Makes a file name more human friendly to read.
 */
function name_from_source(source) {
  if (source == "-") {
    return "-"
  }
  //assume source is a file name
  var file = source.replace(/^.*\/([^\/]+)$/,"$1");
  var noext = file.replace(/\.[^\.]+$/, "");
  return noext.replace(/_/g, " ");
}

/*
 * pre_load_setup
 *
 *  Sets up initial variables which may be
 *  required for the HTML document creation.
 */
function pre_load_setup() {
  for (var i = 0; i < palate.length -1; i++) {
    s_motifs[i] = null;
    s_swatches[i] = null;
    s_logos[i] = null;
  }
  var motifs = data["motifs"];
  motifs.sort(sort_evalue);
  var select_num = Math.min(3, motifs.length);
  for (var i = 0; i < select_num; i++) {
    var motif = motifs[i];
    motif["colouri"] = i+1;
    s_motifs[i] = motif;
  }
  var seq_db = data['sequence_db'];
  if (!seq_db['name']) seq_db['name'] = name_from_source(seq_db['source']);
  // get the names of the motif databases
  var dbs = data['motif_dbs'];
  for (var i = 0; i < dbs.length; i++) {
    var db = dbs[i];
    if (!db['name']) db['name'] = name_from_source(db['source']);
  }
}

/*
 * $
 *
 * Shorthand function for getElementById
 */
function $(el) {
  return document.getElementById(el);
}

/*
 * coords
 *
 * Calculates the x and y offset of an element.
 * From http://www.quirksmode.org/js/findpos.html
 */
function coords(elem) {
  var myX = myY = 0;
  if (elem.offsetParent) {
    do {
      myX += elem.offsetLeft;
      myY += elem.offsetTop;
    } while (elem = elem.offsetParent);
  }
  return [myX, myY];
}

/*
 * help_popup
 *
 * Moves around help pop-ups so they appear
 * below an activator.
 */
function help_popup(activator, popup_id) {
  if (help_popup.popup === undefined) {
    help_popup.popup = null;
  }
  if (help_popup.activator === undefined) {
    help_popup.activator = null;
  }

  if (typeof(activator) == 'undefined') { // no activator so hide
    help_popup.popup.style.display = 'none';
    help_popup.popup = null;
    return;
  }
  var pop = $(popup_id);
  if (pop == help_popup.popup) {
    if (activator == help_popup.activator) {
      //hide popup (as we've already shown it for the current help button)
      help_popup.popup.style.display = 'none';
      help_popup.popup = null;
      return; // toggling complete!
    }
  } else if (help_popup.popup != null) {
    //activating different popup so hide current one
    help_popup.popup.style.display = 'none';
  }
  help_popup.popup = pop;
  help_popup.activator = activator;

  //must make the popup visible to measure it or it has zero width
  pop.style.display = 'block';
  var xy = coords(activator);
  var padding = 10;
  var edge_padding = 15;
  var scroll_padding = 15;

  var pop_left = (xy[0] + (activator.offsetWidth / 2)  - (pop.offsetWidth / 2));
  var pop_top = (xy[1] + activator.offsetHeight + padding);

  // ensure the box is not past the top or left of the page
  if (pop_left < 0) pop_left = edge_padding;
  if (pop_top < 0) pop_top = edge_padding;
  // ensure the box does not cause horizontal scroll bars
  var page_width = null;
  if (window.innerWidth) {
    page_width = window.innerWidth;
  } else if (document.body) {
    page_width = document.body.clientWidth;
  }
  if (page_width) {
    if (pop_left + pop.offsetWidth > page_width) {
      pop_left = page_width - pop.offsetWidth - edge_padding - scroll_padding; //account for scrollbars
    }
  }

  pop.style.left = pop_left + "px";
  pop.style.top = pop_top + "px";
}

function num_keys(e) {
  if (!e) var e = window.event;
  var code = (e.keyCode ? e.keyCode : e.which);
  var keychar = String.fromCharCode(code);
  var numre = /\d/;
  // only allow 0-9 and various control characters (Enter, backspace, delete)
  if (code != 8 && code != 13 && code != 46 && !numre.test(keychar)) {
    e.preventDefault();
  }
}

/*
 * toggle_column
 *
 * Adds or removes a class from the table displaying the 
 * centrally enriched motifs. This is primary used to set the visibility
 * of columns by using css rules. If the parameter 'show' is not passed
 * then the existence of the class will be toggled, otherwise it will be
 * included if show is false.
 */
function toggle_column(cls, show) {
  var tbl = $("motifs");
  var classes = tbl.className;
  var list = classes.replace(/^\s+/, '').replace(/\s+$/, '').split(/\s+/);
  var found = false;
  for (var i = 0; i < list.length; i++) {
    if (list[i] == cls) {
      list.splice(i, 1);
      i--;
      found = true;
    }
  }
  if (show === undefined) {
    if (!found) list.push(cls);
  } else {
    if (!show) list.push(cls);
  }
  tbl.className = list.join(" ");
}

/*
 * toggle_filter
 *
 * Called when the user clicks a checkbox
 * to enable/disable a filter option.
 */
function toggle_filter(chkbox, filter_id) {
  var filter = $(filter_id);
  filter.disabled = !(chkbox.checked);
  if (!filter.disabled) {
    filter.focus();
    if (filter.select) filter.select();
  }
}

/*
 * enable_filter
 *
 * Called when the user clicks a filter label.
 * Enables the filter.
 */
function enable_filter(chkbox_id, filter_id) {
  var chkbox = $(chkbox_id);
  if (!chkbox.checked) {
    var filter = $(filter_id);
    $(chkbox_id).checked = true;
    filter.disabled = false;
    filter.focus();
    if (filter.select) filter.select();
  }
}

/*
 * update_filter
 *
 * If the key event is an enter key press then
 * update the filter on the CEM table
 */
function update_filter(e) {
  if (!e) var e = window.event;
  var code = (e.keyCode ? e.keyCode : e.which);
  if (code == 13) {
    e.preventDefault();
    make_CEM_table();
  }
}

/*
 * clear_selection
 *
 * Called when the user clicks the X in the
 * title of the centrally enriched motifs and
 * causes all the motifs to be deselected.
 */
function clear_selection() {
  for (var i = 1; i < palate.length; i++) {
    var motif = s_motifs[i-1];
    var swatch = s_swatches[i-1];
    s_motifs[i-1] = null;
    s_swatches[i-1] = null;
    s_logos[i-1] = null;
    if (motif) delete motif['colouri'];
    if (swatch) swatch.style.backgroundColor = palate[0];
  }
  make_PM_table();
  make_MP_graph();
}

/*
 * toggle_graph_motif
 *
 * Activated when the user clicks on a swatch in the centrally enriched motifs 
 * table. If the motif is already selected it deselects it otherwise it picks 
 * an unused colour and selects it for graphing.
 */
function toggle_graph_motif(e) {
  var swatch;
  if (!e) var e = window.event;
  if (e.target) swatch = e.target;
  else if (e.srcElement) swatch = e.srcElement;
  // in case we land on a text node
  if (swatch.nodeType == 3) swatch = swatch.parentNode;
  // find the containing row
  var row = swatch.parentNode;
  while (!row['motif']) row = row.parentNode;
  // get the attached motif
  var motif = row['motif'];
  if (motif['colouri'] && motif['colouri'] != 0) {
    // deselect the motif
    var i = motif['colouri'];
    s_motifs[i-1] = null;
    s_swatches[i-1] = null;
    s_logos[i-1] = null;
    delete motif['colouri'];
    swatch.style.backgroundColor = palate[0];
  } else {
    // select an unused colour
    var i;
    for (i = 1; i < palate.length; i++) {
      if (!s_motifs[i-1]) break;
    }
    if (i == palate.length) {
      alert("All graph colours used. Please deselect motifs before adding more.");
      return;
    }
    s_motifs[i-1] = motif;
    s_swatches[i-1] = swatch;
    motif['colouri'] = i;
    swatch.style.backgroundColor = palate[i];
  }
  make_PM_table();
  make_MP_graph();
}

/*
 * move_legend
 *
 * Called when the user clicks on the graph
 * to move the legend location.
 */
function move_legend(e) {
  var target;
  if (!e) var e = window.event;
  if (e.target) target = e.target;
  else if (e.srcElement) target = e.srcElement;
  var elemXY = coords(target);
  var posx = 0;
  var posy = 0;
  if (e.pageX || e.pageY)   {
    posx = e.pageX;
    posy = e.pageY;
  }
  else if (e.clientX || e.clientY)   {
    posx = e.clientX + document.body.scrollLeft
      + document.documentElement.scrollLeft;
    posy = e.clientY + document.body.scrollTop
      + document.documentElement.scrollTop;
  }
  var x = posx - elemXY[0];
  var y = posy - elemXY[1];
  legend_x = x - legend_width/2;
  legend_y = y - legend_height/2;
  if (parseInt($("legend").value) != 0) make_MP_graph();
}

/*
 * hover_logo
 *
 * Activated when the user hovers their cursor over a row in the centrally 
 * enriched motifs table. After a fifth of a second delay, displays a box with 
 * the logo and reverse complement logo.
 */
function hover_logo(e) {
  var target;
  if (!e) var e = window.event;
  if (e.target) target = e.target;
  else if (e.srcElement) target = e.srcElement;
  while (!target['motif']) {
    if (target.nodeName == 'BODY') return;
    target = target.parentNode;
  }
  var motif = target['motif'];
  var popup = $("logo_popup");
  popup.style.left = (e.pageX + 20) + "px";
  popup.style.top = (e.pageY + 20) + "px";
  if (popup['motif'] == motif) {
    popup.style.display = "block";
  } else if (logo_motif != motif) {
    if (logo_timer) clearTimeout(logo_timer);
    logo_motif = motif;
    logo_timer = setTimeout(popup_logo, 200);
  }
}

/*
 * dehover_logo
 *
 * Activated when the user moves their cursor off a row in the centrally 
 * enriched motifs table. Hides the logo box (or stops it from being displayed).
 */
function dehover_logo(e) {
  var popup = $("logo_popup");
  popup.style.display = "none";
  if (logo_timer) clearTimeout(logo_timer);
  logo_motif = null;
}

/*
 * popup_logo
 *
 * Activated when the user has had the cursor over a row in the centrally 
 * enriched motifs table for longer than 1/5th of a second. It draws the
 * motif logos in a popup and displays the popup.
 */
function popup_logo() {
  if (logo_motif == null) return;
  var pspm = new Pspm(logo_motif['pwm'], logo_motif['id'], 0, 0, 
      logo_motif['motif_nsites'], logo_motif['motif_evalue']);
  var canvas = $("logo_popup_canvas");
  var logo = logo_1(dna_alphabet, "", pspm);
  draw_logo_on_canvas(logo, canvas, false, 0.5);
  var pspm_rc = pspm.copy().reverse_complement(dna_alphabet);
  var canvas_rc = $("logo_popup_canvas_rc");
  var logo_rc = logo_1(dna_alphabet, "", pspm_rc);
  draw_logo_on_canvas(logo_rc, canvas_rc, false, 0.5);

  var popup = $("logo_popup");
  popup.style.display = "block";
  popup['motif'] = logo_motif;
  logo_timer = null;
  logo_motif = null;
}

/*
 * swap_colour
 *
 * Activated when the user clicks a swatch in the plotted motifs table.
 * If a swatch has already been selected then swap colours with this one,
 * otherwise record which swatch has been selected.
 */
function swap_colour(e) {
  var swatch;
  if (!e) var e = window.event;
  if (e.target) swatch = e.target;
  else if (e.srcElement) swatch = e.srcElement;
  var row = swatch;
  while (!row['motif']) row = row.parentNode;
  var motif = row['motif'];
  if (swap == null) {
    swatch.appendChild(document.createTextNode("\u21c5"));
    swap = motif;
  } else if (swap == motif) {
    while (swatch.firstChild) swatch.removeChild(swatch.firstChild);
    swap = null;
  } else {
    var swapi = swap['colouri'];
    var motifi = motif['colouri'];
    motif['colouri'] = swapi;
    swap['colouri'] = motifi;
    // swap swatches
    var temp = s_swatches[swapi-1];
    s_swatches[swapi-1] = s_swatches[motifi-1];
    s_swatches[motifi-1] = temp;
    // swap motifs
    temp = s_motifs[swapi-1];
    s_motifs[swapi-1] = s_motifs[motifi-1];
    s_motifs[motifi-1] = temp;
    // swap logos
    temp = s_logos[swapi-1];
    s_logos[swapi-1] = s_logos[motifi-1];
    s_logos[motifi-1] = temp;
    // update swatch colours
    s_swatches[swapi-1].style.backgroundColor = palate[swapi];
    s_swatches[motifi-1].style.backgroundColor = palate[motifi];
    swap = null;
    make_PM_table();
    make_MP_graph();
  }
}

/*
 * set_colour
 *
 * Activated when the user clicks a swatch in the unused colours section.
 * If a swatch has already been selected then set its colour to this one,
 * otherwise warn the user that they must select a motif swatch first.
 */
function set_colour(e) {
  var swatch;
  if (!e) var e = window.event;
  if (e.target) swatch = e.target;
  else if (e.srcElement) swatch = e.srcElement;
  var colouri = swatch['colouri'];
  if (swap) {
    var swapi = swap['colouri'];
    swap['colouri'] = colouri;
    s_swatches[colouri-1] = s_swatches[swapi-1];
    s_motifs[colouri-1] = s_motifs[swapi-1];
    s_logos[colouri-1] = s_logos[swapi-1];
    s_swatches[swapi-1] = null;
    s_motifs[swapi-1] = null;
    s_logos[swapi-1] = null;
    s_swatches[colouri-1].style.backgroundColor = palate[colouri];
    swap = null;
    make_PM_table();
    make_MP_graph();
  } else {
    alert("You must select a motif to set to this colour first.");
  }
}

/*
 * page_loaded
 *
 * Called when the page has loaded for the first time.
 */
function page_loaded() {
  post_load_setup();
}

/*
 * page_loaded
 *
 * Called when a cached page is reshown.
 */
function page_shown(e) {
  if (e.persisted) post_load_setup();
}

/*
 * post_load_setup
 *
 * Setup state that is dependant on everything having been loaded already.
 */
function post_load_setup() {
  $("filter_id").disabled = !($("filter_on_id").checked);
  $("filter_alt").disabled = !($("filter_on_alt").checked);
  $("filter_evalue").disabled = !($("filter_on_evalue").checked);
  $("filter_binwidth").disabled = !($("filter_on_binwidth").checked);
  toggle_column("hide_db", $("show_db").checked);
  toggle_column("hide_name", $("show_name").checked);
  toggle_column("hide_pvalue", $("show_pvalue").checked);
  toggle_column("hide_maxprob", $("show_maxprob").checked);
  toggle_column("hide_bsites", $("show_bsites").checked);
  toggle_column("hide_tsites", $("show_tsites").checked);
  make_CEM_table();
  make_PM_table();
  make_MP_graph();
}

/*
 *  sort_id
 *
 *  Takes 2 motif objects and compares them based on id and database.
 */
function sort_id(m1, m2) {
  var diff;
  diff = m1['id'].localeCompare(m2['id']);
  if (diff == 0) {
    diff = m1['db'] - m2['db'];
  }
  return diff;
}

/*
 * sort_alt
 *
 * Takes 2 motif objects and compares them based on alternate id.
 */
function sort_alt(m1, m2) {
  var diff;
  if (m1['alt'] && m2['alt']) {
    diff = m1['alt'].localeCompare(m2['alt']);
    if (diff != 0) return diff;
    return sort_evalue(m1, m2);
  } else {
    if (m1['alt']) {
      return -1;
    } else {
      return 1;
    }
  }
}

/*
 * sort_evalue
 *
 * Takes 2 motif objects and compares them based on the log_pvalue.
 */
function sort_evalue(m1, m2) {
  var diff;
  diff = m1['log_pvalue'] - m2['log_pvalue'];
  if (diff != 0) return diff;
  diff = m1['bin_width'] - m2['bin_width'];
  if (diff != 0) return diff;
  return sort_id(m1, m2);
}

/*
 * sort_binwidth
 *
 * Takes 2 motif objects and compares them based on the bin_width.
 */
function sort_binwidth(m1, m2) {
  var diff;
  diff = m1['bin_width'] - m2['bin_width'];
  if (diff != 0) return diff;
  diff = m1['log_pvalue'] - m2['log_pvalue'];
  if (diff != 0) return diff;
  return sort_id(m1, m2);
}

/*
 * sort_probability
 *
 * Takes 2 motif objects and compares them based on the maximum probability.
 */
function sort_probability(m1, m2) {
  var diff;
  diff =  m2['max_prob'] - m1['max_prob'];
  if (diff != 0) return diff;
  return sort_evalue(m1, m2);
}

/*
 * sort_bin_sites
 *
 * Takes 2 motif objects and compares them based on the bin sites.
 */
function sort_bin_sites(m1, m2) {
  var diff;
  diff = m2['bin_sites'] - m1['bin_sites'];
  if (diff != 0) return diff;
  return sort_evalue(m1, m2);
}

/*
 * sort_total_sites
 *
 * Takes 2 motif objects and compares them based on the total sites.
 */
function sort_total_sites(m1, m2) {
  var diff;
  diff = m2['total_sites'] - m1['total_sites'];
  if (diff != 0) return diff;
  return sort_evalue(m1, m2);
}

/*
 * log2str
 *
 * Converts a log value into scientific notation.
 */
function log2str(log_val, precision) {
  var log10_val = log_val / Math.log(10);
  var e = Math.floor(log10_val);
  var m = Math.pow(10, log10_val - e);
  if (m + (0.5 * Math.pow(10, -precision)) >= 10) {
    m = 1;
    e += 1;
  }
  return "" + m.toFixed(precision) + "e" + e;
}

/*
 * pvstr
 *
 * Gets the p-value of the motif in string form.
 */
function pvstr(motif) {
  return log2str(motif['log_pvalue'], 1);
}

/*
 * evstr
 *
 * Gets the E-value of the motif in string form.
 */
function evstr(motif) {
  return log2str(motif['log_pvalue'] + Math.log(data['tested']), 1);
}

/*
 *  make_link
 *
 *  Creates a text node and if a URL is specified it surrounds it with a link. 
 *  If the URL doesn't begin with "http://" it automatically adds it, as 
 *  relative links don't make much sense in this context.
 */
function make_link(text, url) {
  var textNode = null;
  var link = null;
  if (text) textNode = document.createTextNode(text);
  if (url) {
    if (url.indexOf("//") == -1) {
      url = "http://" + url;
    }
    link = document.createElement('a');
    link.href = url;
    if (textNode) link.appendChild(textNode);
    return link;
  } 
  return textNode;
}

/*
 * make_swatch
 *
 * Make a swatch block.
 */
function make_swatch(colouri) {
  var swatch = document.createElement('div');
  swatch.className = 'swatch';
  swatch.style.backgroundColor = palate[colouri];
  swatch.style.color = text_palate[colouri];
  return swatch;
}

/*
 * add_cell
 *
 * Add a cell to the table row.
 */
function add_cell(row, node, cls) {
  var cell = row.insertCell(row.cells.length);
  if (node) cell.appendChild(node);
  if (cls) cell.className = cls;
}

/*
 * add_text_cell
 *
 * Add a text cell to the table row.
 */
function add_text_cell(row, text, cls) {
  var node = null;
  if (text) node = document.createTextNode(text);
  add_cell(row, node, cls);
}

/*
 * make_CEM_table
 *
 * Generate the table which lists centrally enriched motifs.
 */
function make_CEM_table() {
  var evalue_re = /^([+]?\d+(?:\.\d+)?)(?:[eE]([+-]\d+))?$/;
  //make a list of the filtered data
  // get the db filter
  var filter_on_db = $("filter_on_db").checked;
  var db_num = $("filter_db").value;
  // get the id filter
  var filter_on_id = $("filter_on_id").checked;
  var id_pat = $("filter_id").value;
  var id_re;
  try {
    id_re = new RegExp(id_pat);
    $("filter_id").className = "";
  } catch (err) {
    filter_on_id = false;
    $("filter_id").className = "error";
  }
  // get the name filter
  var filter_on_alt = $("filter_on_alt").checked;
  var alt_pat = $("filter_alt").value;
  var alt_re;
  try {
    alt_re = new RegExp(alt_pat);
    $("filter_alt").className = "";
  } catch (err) {
    filter_on_alt = false;
    $("filter_alt").className = "error";
  }
  // get the evalue filter
  var filter_on_evalue = $("filter_on_evalue").checked;
  var evalue_text = $("filter_evalue").value;
  var log_pvalue_max;
  var parts = evalue_re.exec(evalue_text);
  if (parts && parseFloat(parts[1]) != 0) {
    var m = parseFloat(parts[1]);
    var e = (parts.length == 3 && parts[2] != null ? parseInt(parts[2]) : 0);
    var log_evalue = (((Math.log(m)/Math.log(10)) + e) * Math.log(10));
    log_pvalue_max = log_evalue - Math.log(data['tested']);
    $("filter_evalue").className = "";
  } else {
    filter_on_evalue = false;
    $("filter_evalue").className = "error";
  }
  // get the bin width filter
  var filter_on_binwidth = $("filter_on_binwidth").checked;
  var binwidth_max = parseInt($("filter_binwidth").value);
  if (isNaN(binwidth_max) || binwidth_max < 1) {
    filter_on_binwidth = false;
    $("filter_binwidth").className = "error";
  } else {
    $("filter_binwidth").className = "";
  }
  // iterate over all the motifs and discard those which don't match the filter
  var motifs = data['motifs'];
  var filtered = [];
  for (var i = 0; i < motifs.length; i++) {
    var motif = motifs[i];
    if (filter_on_db && motif['db'] != db_num) continue;
    if (filter_on_id && !id_re.test(motif['id'])) continue;
    if (filter_on_alt && !alt_re.test(motif['alt'])) continue;
    if (filter_on_evalue && motif['log_pvalue'] > log_pvalue_max) continue;
    if (filter_on_binwidth && motif['bin_width'] > binwidth_max) continue;
    filtered.push(motif);
  }
  // sort by evalue (for now)
  var sort_cmp;
  switch(parseInt($('sort').value)) {
    case 0:
      sort_cmp = sort_id;
      break;
    case 1:
      sort_cmp = sort_alt;
      break;
    case 2:
      sort_cmp = sort_evalue;
      break;
    case 3:
      sort_cmp = sort_binwidth;
      break;
    case 4:
      sort_cmp = sort_bin_sites;
      break;
    case 5:
      sort_cmp = sort_total_sites;
      break;
    case 6:
      sort_cmp = sort_probability;
      break;
    default:
      sort_cmp = sort_evalue;
  }
  filtered.sort(sort_cmp);
  // limit the list
  var filter_on_limit = $("filter_on_top").checked;
  var limit = parseInt($("filter_top").value);
  if (isNaN(limit) || limit < 1) {
    filter_on_limit = false;
    $("filter_top").className = "error";
  } else {
    $("filter_top").className = "";
  }
  if (filter_on_limit) {
    if (filtered.length > limit) filtered.length = limit;
  }
  // re-add any omitted s_motifs motifs
  outer_loop:
  for (var i = 0; i < s_motifs.length; i++) {
    if (s_motifs[i] == null) continue;
    for (var j =0; j < filtered.length; j++) {
      if (filtered[j]['id'] === s_motifs[i]['id']) {
        continue outer_loop;
      }
    }
    filtered.push(s_motifs[i]);
  }
  filtered.sort(sort_cmp);

  // clear the table and add the items
  var tbl = $("motifs");
  var tbody = tbl.tBodies[0];
  while (tbody.rows.length > 0) {
    tbody.deleteRow(0);
  }
  var motif_dbs = data['motif_dbs'];
  // add the new rows to the table
  for (var i = 0; i < filtered.length; i++) {
    var motif = filtered[i];
    var colouri = motif['colouri'];
    if (!colouri) colouri = 0;
    var row = tbody.insertRow(tbody.rows.length);
    row.onmouseover = hover_logo;
    row.onmousemove = hover_logo;
    row.onmouseout = dehover_logo;
    row['motif'] = motif;
    var swatch = make_swatch(colouri);
    swatch.onclick = toggle_graph_motif;
    if (colouri != 0) s_swatches[colouri -1] = swatch;
    add_cell(row, swatch);
    add_text_cell(row, motif_dbs[motif['db']]['name'], 'col_db');
    add_cell(row, make_link(motif['id'], motif['url']));
    add_text_cell(row, motif['alt'], "col_name");
    add_text_cell(row, evstr(motif));
    add_text_cell(row, pvstr(motif), "col_pvalue");
    add_text_cell(row, motif['bin_width'], 'col_binwidth');
    add_text_cell(row, Math.round(motif['bin_sites']), "col_bsites");
    add_text_cell(row, motif['total_sites'], "col_tsites");
    add_text_cell(row, motif['max_prob'].toExponential(1), "col_maxprob");
  }
}

/*
 * make_PM_table
 *
 * Generate the table which lists plotted motifs
 */
function make_PM_table() {
  swap = null;
  var graphed = [];
  var unused = [];
  for (var i = 1; i < palate.length; i++) {
    if (s_motifs[i-1]) graphed.push(s_motifs[i-1]);
    else unused.push(i);
  }
  graphed.sort(sort_evalue);

  var tbl = $("graph_list");
  var tbody = tbl.tBodies[0];
  while (tbody.rows.length > 0) {
    tbody.deleteRow(0);
  }
  // add the new rows to the table
  for (var i = 0; i < graphed.length; i++) {
    var motif = graphed[i];
    var colouri = motif['colouri'];
    if (!colouri) colouri = 0;
    var row = tbody.insertRow(tbody.rows.length);
    row['motif'] = motif;
    var swatch = make_swatch(colouri);
    swatch.onmousedown = swap_colour;
    add_cell(row, swatch);
    add_cell(row, make_link(motif['id'], motif['url']));
    if (!s_logos[colouri-1]) {
      s_logos[colouri-1] = document.createElement("canvas");
      var pspm = new Pspm(motif['pwm'], motif['id'], 0, 0, 
          motif['motif_nsites'], motif['motif_evalue']);
      var logo = logo_1(dna_alphabet, "", pspm);
      draw_logo_on_canvas(logo, s_logos[colouri-1], false, 0.3);
    }
    add_cell(row, s_logos[colouri-1]);
  }
  var div = $("unused_colours");
  while (div.firstChild) div.removeChild(div.firstChild);
  $("unused_colours_section").style.display = (unused.length > 0 ? "block" : "none");
  for (var i = 0; i < unused.length; i++) {
    var swatch = make_swatch(unused[i]);
    swatch['colouri'] = unused[i];
    swatch.onclick = set_colour;
    div.appendChild(swatch);
  }
}

/*
 * make_MP_graph
 *
 * Create a motif probability graph on the canvas.
 */
function make_MP_graph() {
  var canvas = $("graph");
  canvas.width = canvas.width;
  if (canvas.getContext) {
    var ctx = canvas.getContext('2d');
    make_MP_graph2(ctx, canvas.width, canvas.height);
  }
}

function download_eps() {
  var canvas = $("graph");
  canvas.width = canvas.width;
  if (canvas.getContext) {
    var ctx = canvas.getContext('2d');
    var eps_ctx = new EpsContext(ctx, canvas.width, canvas.height);
    eps_ctx.register_font("14pt Helvetica", "Helvetica", 14 / 3 * 4);
    eps_ctx.register_font("16px Helvetica", "Helvetica", 16);
    eps_ctx.register_font("9px Helvetica", "Helvetica", 9);
    make_MP_graph2(ctx, canvas.width, canvas.height);
    $("eps_content").value = eps_ctx.eps();
  }
}

function make_MP_graph2(ctx, width, height) {
  var motif_list = $("motif_list");
  var windo = parseInt($("windo").value);
  if (isNaN(windo) || windo < 1) {
    windo = 20;
    $("windo").value = 20;
  }
  var type = parseInt($("plot_type").value);
  var legend = parseInt($("legend").value);
  var motifs = [];
  for (var i = 0; i < s_motifs.length; i++) 
    if (s_motifs[i] != null) motifs.push(s_motifs[i]);
  motifs.sort(sort_evalue);
  var graph = calc_graph(type, windo, data['seqlen'], motifs);
  draw_graph(ctx, width, height, graph, legend, legend_x, legend_y);
}

/*
 * calc_graph
 *
 * Calculate the lines that make up the graph
 */
function calc_graph(type, windo, seq_len, motifs) {
  var  min = (motifs.length == 0 ? 0 : motifs[0]['sites'].length);
  for (var i = 1; i < motifs.length; i++) 
    if (motifs[i]['sites'].length < min) min = motifs[i]['sites'].length;
  if (min < windo) {
    return {'lines': [], 'scale': calc_Y_scale(1.0), 'start': -(seq_len / 2), 
      'length': seq_len, 'thin_lines': false};
  }
  var graph = {};
  // find sequence mid point
  var mid = seq_len / 2;
  var lines;
  switch (type) {
    case 0:
      lines = calc_moving_avg(motifs, seq_len, windo);
      break;
    case 1:
      lines = calc_weighted_moving_avg(motifs, seq_len, windo);
      break;
    default:
      throw "Unknown graph type (" + type + ")";
  }
  var max_prob = trim_lines(lines);
  graph['thin_lines'] = windo < 10;
  graph['lines'] = lines;
  graph['scale'] = calc_Y_scale(max_prob);
  graph['start'] = -mid;
  graph['length'] = seq_len;
  return graph;
}

/*
 * calc_weighted_moving_avg
 *
 * Smooth the lines by applying a weighted moving average function
 */
function calc_weighted_moving_avg(motifs, sequence_length, windo) {
  var lines = [];
  // calculate weights
  var half_window = windo / 2;
  var weights = [];
  var total_weight = 0;
  for (var i = 0; i < windo; i++) {
    var pos = i + 0.5;
    var weight = (pos < half_window ? pos / half_window : (windo - pos) / half_window);
    weights.push(weight);
    total_weight += weight;
  }
  // calculate points
  for (var i = 0; i < motifs.length; i++) {
    var motif = motifs[i];
    var sites = motif['sites'];
    var x = [];
    var y = [];
    var xpos = (motif.len / 2) - (sequence_length / 2) + half_window;
    var end = sites.length - windo;
    for (var j = 0; j < end; j++, xpos += 1) {
      var sum = 0;
      for (var k = 0; k < windo; k++) {
        sum += sites[j + k] * weights[k];
      }
      var avg = sum / total_weight;
      var prob = avg / motif['total_sites'];
      y.push(prob);
      x.push(xpos);
    }
    var name = motif['id'];
    if (motif['alt']) name = motif['alt'] + " " + motif['id'];
    lines.push({'x': x, 'y': y, 'id': name, 'pv': 'p=' + pvstr(motif), 'colouri': motif['colouri']});
  }
  return lines;
}

/*
 * calc_moving_avg
 *
 * Takes the probabilities for each of the sites in the
 * sequence and generates smoothed probabilities using
 * a moving average.
 */
function calc_moving_avg(motifs, sequence_length, windo) {
  var lines = [];
  // calculate weights
  var half_window = windo / 2;
  // calculate points
  for (var i = 0; i < motifs.length; i++) {
    var motif = motifs[i];
    var sites = motif['sites'];
    var x = [];
    var y = [];
    var xpos = (motif.len / 2) - (sequence_length / 2) + half_window;
    var end = sites.length - windo;
    for (var j = 0; j < end; j++, xpos += 1) {
      var sum = 0;
      for (var k = 0; k < windo; k++) {
        sum += sites[j + k];
      }
      var avg = sum / windo;
      var prob = avg / motif['total_sites'];
      y.push(prob);
      x.push(xpos);
    }
    var name = motif['id'];
    if (motif['alt']) name = motif['alt'] + " " + motif['id'];
    lines.push({'x': x, 'y': y, 'id': name, 'pv': 'p=' + pvstr(motif), 'colouri': motif['colouri']});
  }
  return lines;
}

/*
 * trim_lines
 *
 * Trims the edges of the lines so they all align.
 */
function trim_lines(lines) {
  var max_prob = -INT_MAX;
  var left = -INT_MAX;
  var right = INT_MAX;
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var x = line['x'];
    if (x.length > 0) {
      if (x[0] > left) left = x[0];
      if (x[x.length - 1] < right) right = x[x.length - 1];
    }
  }
  if (left == right) {
    lines.splice(0, lines.length);
    return 1.0;
  }
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var x = line['x'];
    var y = line['y'];
    var left_i = 0;
    while (left_i < x.length && x[left_i] < left) left_i++;
    if (left_i == x.length) { 
      // not enough line to trim, remove line
      lines.splice(i, 1);
      i--;
      continue
    }
    if (left_i == 0) {
      // no trim required
    } else if (x[left_i] == left) {
      // remove some elements
      x.splice(0, left_i);
      y.splice(0, left_i);
    } else {
      // remove some elements and interpolate a new one
      var gradient = (y[left_i] - y[left_i-1]) / (x[left_i] - x[left_i-1]);
      var run = left - x[left_i-1];
      var left_y = y[left_i-1] + gradient * run;
      x.splice(0, left_i, left);
      y.splice(0, left_i, left_y);
    }
    var right_i = x.length - 1;
    while (right_i >= 0 && x[right_i] > right) right_i--;
    if (right_i == 0) {
      // not enough line to trim, remove line
      lines.splice(i, 1);
      i--;
      continue;
    }
    if (right_i == (x.length - 1)) {
      // no trim required
    } else if (x[right_i] == right) {
      // remove some elements
      x.splice(right_i + 1, x.length - right_i - 1);
      y.splice(right_i + 1, y.length - right_i - 1);
    } else {
      // remove some elements and interpolate a new one
      var gradient = (y[right_i+1] - y[right_i]) / (x[right_i+1] - x[right_i]);
      var run = right - x[right_i];
      var right_y = y[right_i] + gradient * run;
      x.splice(right_i + 1, x.length - right_i - 1, right);
      y.splice(right_i + 1, y.length - right_i - 1, right_y);
    }
    for (var j = 0; j < y.length; j++) {
      if (y[j] > max_prob) max_prob = y[j];
    }
  }
  return max_prob;
}

/*
 * calc_Y_scale
 *
 * Calculates the increments on the y axis
 */
function calc_Y_scale(max_prob) {
  if (max_prob == 0) return {'max': 0.01, 'inc': 0.002, 'digits':3};
  // find the minimum number of decimals needed to display the largest
  // digit of the maximum probability
  var decimals = Math.ceil(-(Math.log(max_prob) / Math.log(10)));
  // calculate an increment which is (at minimum) 10 times smaller the the max
  var inc = Math.pow(10, -(decimals+1));
  // round-up the maximum probabilty to its largest digit
  var rounder = Math.pow(10, decimals);
  var max = Math.ceil(max_prob * rounder) / rounder;
  // adjust the increment so it's between 5 and 12 times the maximum
  // probability
  if (inc * 5 < max && inc * 12 > max) {
    inc *= 1;
  } else if (inc * 10 < max && inc * 24 > max) {
    inc *= 2;
  } else if (inc * 25 < max && inc * 60 > max) {
    inc *= 5;
  } else if (inc * 50 < max && inc * 120 > max) {
    inc *= 10;
  }
  while (max - inc >= max_prob) max -= inc;
  return {'max': max, 'inc': inc, 'digits': decimals+1};
  
}

/*
 * draw_graph
 *
 * Draws a motif probability graph
 */
function draw_graph(ctx, w, h, graph, legend, legend_x, legend_y) {
  var gap = 10;
  var l_margin = gap + 30 + 10 * (2 + graph['scale']['digits']);
  var t_margin = 20;
  var b_margin = 60;
  var r_margin = 10;
  legend_metrics = measure_legend(ctx, graph);
  // setting global
  legend_width = legend_metrics['width'];
  legend_height = legend_metrics['height'];
  // constrain legend to within graph area
  legend_x = Math.round(legend_x);
  legend_y = Math.round(legend_y);
  if (legend_x < (l_margin + gap)) {
    legend_x = l_margin + gap;
  } else if ((legend_x + legend_metrics['width']) > (w - r_margin - gap)) {
    legend_x = w - r_margin - legend_metrics['width'] - gap;
  }
  if (legend_y < (t_margin + gap)) {
    legend_y = t_margin + gap;
  } else if ((legend_y + legend_metrics['height']) > (h - b_margin - gap)) {
    legend_y = h - b_margin - legend_metrics['height'] - gap;
  }

  // draw graph
  ctx.save();
  // draw border
  ctx.beginPath();
  ctx.moveTo(l_margin - 0.5, t_margin +0.5);
  ctx.lineTo(l_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, t_margin +0.5);
  ctx.closePath();
  ctx.stroke();
  // draw fineprint
  ctx.save();
  ctx.font = "9px Helvetica";
  ctx.textAlign = "right";
  ctx.textBaseline = "bottom";
  //ctx.fillText("CentriMo " + data["version"], w - r_margin, t_margin - 2);
  ctx.fillText("CentriMo " + data["version"], w - 1, h - 2);
  ctx.restore();
  // draw y axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  draw_y_axis(ctx, 0, h - (t_margin + b_margin), graph);
  ctx.restore();
  // draw y labels
  ctx.save();
  ctx.translate(gap, t_margin);
  draw_y_axis_label(ctx, l_margin, h - (t_margin + b_margin));
  ctx.restore();
  // draw x axis
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  draw_x_axis(ctx, w - (l_margin + r_margin), b_margin, graph);
  ctx.restore();
  // draw top axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  draw_top_axis(ctx, w - (l_margin + r_margin), 0, graph);
  ctx.restore();
  // draw x axis labels
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  draw_x_axis_label(ctx, w - (l_margin + r_margin), b_margin - gap);
  ctx.restore();
  // draw lines
  ctx.save();
  ctx.translate(l_margin, t_margin);
  draw_lines(ctx, w - (l_margin + r_margin), h - (t_margin + b_margin), graph);
  ctx.restore();
  // draw legend
  if (legend != 0) { 
    ctx.save();
    ctx.translate(legend_x, legend_y);
    draw_legend(ctx, graph, legend_metrics);
    ctx.restore();
  }
  ctx.restore();
}

/*
 * draw_x_axis
 */
function draw_x_axis(ctx, w, h, graph) {
  ctx.save();
  ctx.translate(w / 2, 0);
  var tick_max = graph['length'] / 2;
  var nticks = 5
  var tick_inc = Math.round(tick_max / (10*nticks)) * 10
  var scale_x = w / graph['length'];
  ctx.beginPath();
  ctx.moveTo(0.5, -5);
  ctx.lineTo(0.5, 3);
  ctx.stroke();
  ctx.font = "14pt Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  ctx.fillText("0", 0, 5);
  //for (var i = 50; i < tick_max; i += 50) {
  for (var i = tick_inc; i < tick_max; i += tick_inc) {
    var x = Math.round(i * scale_x) + 0.5;
    ctx.beginPath();
    ctx.moveTo(x, -5);
    ctx.lineTo(x, 3);
    ctx.stroke();
    ctx.fillText(""+i, x, 5);
    ctx.beginPath();
    ctx.moveTo(-x, -5);
    ctx.lineTo(-x, 3);
    ctx.stroke();
    ctx.fillText(""+(-i), -x, 5);
  }
  ctx.restore();
}

/*
 * draw_top_axis
 */
function draw_top_axis(ctx, w, h, graph) {
  ctx.save();
  ctx.translate(w / 2, 0);
  var tick_max = graph['length'] / 2;
  var scale_x = w / graph['length'];
  ctx.beginPath();
  ctx.moveTo(0.5, 0);
  ctx.lineTo(0.5, 8);
  ctx.stroke();
  for (var i = 50; i < tick_max; i += 50) {
    var x = Math.round(i * scale_x) + 0.5;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, 8);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-x, 0);
    ctx.lineTo(-x, 8);
    ctx.stroke();
  }
  ctx.restore();
}

/*
 * draw_x_axis_label
 */
function draw_x_axis_label(ctx, w, h) {
  ctx.save();
  ctx.font = "14pt Helvetica";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText("Position of Best Site in Sequence", w/2, h);
  ctx.restore();
}

/*
 * draw_y_axis
 */
function draw_y_axis(ctx, w, h, graph) {
  var scale = graph['scale'];
  ctx.save();
  ctx.font = "14pt Helvetica";
  ctx.textBaseline = "middle";
  ctx.textAlign = "right";

  var y_scale = h / scale['max'];
  for (var p = 0; p < scale['max']; p += scale['inc']) {
    var y = Math.round(h - p * y_scale) + 0.5;
    draw_y_tic(ctx, scale['digits'], y, p);
  }
  draw_y_tic(ctx, scale['digits'], 0.5, scale['max']);

  ctx.restore();
}

/*
 * draw_y_tic
 */
function draw_y_tic(ctx, digits, y, p) {
  ctx.beginPath();
  ctx.moveTo(5, y);
  ctx.lineTo(-3, y);
  ctx.stroke();
  ctx.fillText(p.toFixed(digits), -5, y);
}

/*
 * draw_y_axis_label
 */
function draw_y_axis_label(ctx, w, h) {
  ctx.save();
  ctx.translate(0, h/2);
  ctx.rotate(-Math.PI / 2);
  ctx.font = "14pt Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  ctx.fillText("Probability", 0, 0);
  ctx.restore();
}

/*
 * draw_lines
 */
function draw_lines(ctx, w, h, graph, thin_lines) {
  ctx.save();
  ctx.translate(w/2, 0);
  ctx.strokeStyle = '#DDD';
  ctx.beginPath();
  ctx.moveTo(0.5, 8);
  ctx.lineTo(0.5, h-8);
  ctx.stroke();
  ctx.restore();
  if (graph == null) return;
  ctx.save();
  ctx.lineJoin = "bevel";
  ctx.miterLimit = 0;
  ctx.lineWidth = (graph['thin_lines'] ? 1 : 3);
  var lines = graph['lines'];
  var scale_y = h / graph['scale']['max'];
  var scale_x = w / graph['length'];
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var x_points = line['x'];
    var y_points = line['y'];
    ctx.strokeStyle = palate[line['colouri']];
    ctx.beginPath();
    for (var j = 0; j < x_points.length; j++) {
      if (isNaN(x_points[j])) throw "X NaN!";
      if (isNaN(y_points[j])) throw "Y NaN!";
      var x = (x_points[j] - graph['start']) * scale_x;
      var y = h - y_points[j] * scale_y;
      if (j == 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
  ctx.restore();
}

/*
 * measure_legend
 */
function measure_legend(ctx, graph) {
  var lw, lh, sq_w, id_w, pv_w, lines;
  // get the lines
  lines = graph['lines'];
  // legend height is a function of the line count
  lh = Math.round(lines.length * MPG.legend_line * 1.2 + 2 * MPG.legend_pad);
  // calculate the column widths
  sq_w = MPG.legend_line - 2;
  id_w = 0;
  pv_w = 0;
  ctx.save();
  ctx.font = "" + MPG.legend_line + "px " + MPG.legend_font; 
  for (var i = 0; i < lines.length; i++) {
    var line, len;
    line = lines[i];
    len = ctx.measureText(line['id']).width;
    if (id_w < len) id_w = len;
    len = ctx.measureText(line['pv']).width;
    if (pv_w < len) pv_w = len;
  }
  ctx.restore();
  // legend width is a function of the column widths
  lw = id_w + pv_w + sq_w + 4 * MPG.legend_pad;

  return {'width': lw, 'height': lh, 'id_width': id_w, 'pv_width': pv_w, 'sq_width': sq_w};
}

/*
 * draw_legend
 */
function draw_legend(ctx, graph, metrics) {
  var ln_h, pad, w, h, id_w, pv_w, sq_w, id_x, pv_x, sq_x;
  var lines = graph['lines'];
  if (lines.length == 0) return;
  ln_h = MPG.legend_line;
  pad = MPG.legend_pad;
  w = metrics['width'];
  h = metrics['height'];
  id_w = metrics['id_width'];
  pv_w = metrics['pv_width'];
  sq_w = metrics['sq_width'];
  id_x = 0;
  pv_x = id_x + id_w + pad;
  sq_x = pv_x + pv_w + pad;

  ctx.save();
  ctx.font = "" + ln_h + "px " + MPG.legend_font; 
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
  // draw it
  ctx.save();
  ctx.fillStyle = 'white';
  ctx.fillRect(0.5, 0.5, w-1, h-1);
  ctx.strokeStyle = 'black';
  ctx.strokeRect(0.5, 0.5, w-1, h-1);
  ctx.restore();
  ctx.translate(pad, pad);
  ctx.fillStyle = "black";
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    ctx.translate(0, ln_h);
    ctx.save();
    ctx.fillStyle = palate[line['colouri']];
    ctx.fillRect(sq_x, -sq_w + 0.1 * ln_h, sq_w, sq_w);
    ctx.restore();
    ctx.fillText(line['id'], id_x, 0);
    ctx.fillText(line['pv'], pv_x, 0);
    ctx.translate(0, 0.2 * ln_h);
  }
  ctx.restore();
}

    </script>
    <style type="text/css">
table.inputs {
  margin-top: 20px;
  border-collapse:collapse;
}
table.inputs * td, table.inputs * th {
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 1px;
  padding-bottom: 1px;
}
table.motifs {
  margin-top: 20px;
  border-collapse:collapse;
}
table.motifs * td, table.motifs * th {
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 1px;
  padding-bottom: 1px;
}
table.motifs * td.col_binwidth, table.motifs * td.col_bsites, table.motifs * td.col_tsites {
  text-align: right;
  padding-right: 40px;
}
table.motifs tbody tr:hover { 
  background: #ccccff; 
}
table.hide_db .col_db {
  display: none;
}
table.hide_name .col_name {
  display: none;
}
table.hide_pvalue .col_pvalue {
  display: none;
}
table.hide_maxprob .col_maxprob {
  display: none;
}
table.hide_bsites .col_bsites {
  display: none;
}
table.hide_tsites .col_tsites {
  display: none;
}
div.graph_options_section {
  width:30%; 
  float:right;
}
div.graph_options_section h5 {
  margin-top: 10px;
}
table.graph_list {
  border-collapse:collapse;
}
table.graph_list * td, table.graph_list * th {
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 1px;
  padding-bottom: 1px;
}
th.deselect {
  font-size:25px; 
  cursor: default;
}
th.deselect:hover {
  color: red;
}
div.filter {
  display: inline-block;
  padding-right: 10px;
}
div.swatch {
  margin: auto;
  width: 20px;
  height: 20px;
  text-align: center;
  font-size: 16px;
  border: 1px solid black;
  cursor: default;
}
div.swatch:hover {
  width: 16px;
  height: 16px;
  font-size: 16px;
  border: 3px outset black;
}
div.swatch:active {
  width: 16px;
  height: 16px;
  font-size: 16px;
  border: 3px inset black;
}
div.pop_logo {
  position:absolute;
  z-index:1;
  top:0px;
  left:0px;
  border: 3px outset black;
  background-color: white;
  display:none;
}
div.pop_colour {
  position:absolute;
  z-index:1;
  top:0px;
  left:0px;
  margin-left: -13px;
  margin-top: -13px;
  display:none;

}
div.pop_content {
  position:absolute;
  z-index:1;
  width:300px;
  padding: 5px;
  background: #E4ECEC;
  font-size: 12px;
  font-family: Arial;
  border-style: double;
  border-width: 3px;
  border-color: #AA2244;
  display:none;
}

#unused_colours div.swatch {
  display: inline-block;
  margin-right: 5px;
}

input.error:enabled {
  background: #FF5555;
}


    </style>
    <style type="text/css">
        /* The following is the content of meme.css */
        body { background-color:white; font-size: 12px; font-family: Verdana, Arial, Helvetica, sans-serif;}

        div.help {
          display: inline-block;
          margin: 0px;
          padding: 0px;
          width: 12px;
          height: 13px;
          cursor: pointer;
          background-image: url("help.gif");
          background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAANAQMAAACn5x0BAAAAAXNSR0IArs4c6QAAAAZQTFRFAAAAnp6eqp814gAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH2gMJBQgGYqhNZQAAACZJREFUCNdj+P+BoUGAoV+AYeYEEGoWYGgTYGgRAAm2gRGQ8f8DAOnhC2lYnqs6AAAAAElFTkSuQmCC");
        }

        div.help2 {
          color: #999;
          display: inline-block;
          width: 12px;
          height: 12px;
          border: 1px solid #999;
          font-size: 13px;
          line-height:12px;
          font-family: Helvetica, sans-serif;
          font-weight: bold;
          font-style: normal;
          cursor: pointer;
        }
        div.help2:hover {
          color: #000;
          border-color: #000;
        }
        
        p.spaced { line-height: 1.8em;}
        
        span.citation { font-family: "Book Antiqua", "Palatino Linotype", serif; color: #004a4d;}

        p.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}

        td.jump { font-size: 13px; color: #ffffff; background-color: #00666a;
          font-family: Georgia, "Times New Roman", Times, serif;}

        a.jump { margin: 15px 0 0; font-style: normal; font-variant: small-caps;
          font-weight: bolder; font-family: Georgia, "Times New Roman", Times, serif;}

        h2.mainh {font-size: 1.5em; font-style: normal; margin: 15px 0 0;
          font-variant: small-caps; font-family: Georgia, "Times New Roman", Times, serif;}

        h2.line {border-bottom: 1px solid #CCCCCC; font-size: 1.5em; font-style: normal;
          margin: 15px 0 0; padding-bottom: 3px; font-variant: small-caps;
          font-family: Georgia, "Times New Roman", Times, serif;}

        h4 {border-bottom: 1px solid #CCCCCC; font-size: 1.2em; font-style: normal;
          margin: 10px 0 0; padding-bottom: 3px; font-family: Georgia, "Times New Roman", Times, serif;}

        h5 {margin: 0px}

        a.help { font-size: 9px; font-style: normal; text-transform: uppercase;
          font-family: Georgia, "Times New Roman", Times, serif;}

        div.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}
        
        div.pad1 { margin: 10px 5px;}

        div.pad2 { margin: 25px 5px 5px;}
        h2.pad2 { padding: 25px 5px 5px;}

        div.pad3 { padding: 5px 0px 10px 30px;}

        div.box { border: 2px solid #CCCCCC; padding:10px;}

        div.bar { border-left: 7px solid #00666a; padding:5px; margin-top:25px; }

        div.subsection {margin:25px 0px;}

        img {border:0px none;}

        th.majorth {text-align:left;}
        th.minorth {font-weight:normal; text-align:left; width:8em; padding: 3px 0px;}
        th.actionth {font-weight:normal; text-align:left;}

        .strand_name {text-align:left;}
        .strand_side {padding:0px 10px;}
        .strand_start {padding:0px 10px;}
        .strand_pvalue {text-align:center; padding:0px 10px;}
        .strand_lflank {text-align:right; padding-right:5px; font-weight:bold; font-size:large; font-family: 'Courier New', Courier, monospace; color:gray;}
        .strand_seq {text-align:center; font-weight:bold; font-size:large; font-family: 'Courier New', Courier, monospace;}
        .strand_rflank {text-align:left; padding-left:5px; font-weight:bold; font-size:large; font-family: 'Courier New', Courier, monospace; color:gray;}

        .block_td {height:25px;}
        .block_container {position:relative; width:98%; height:25px; padding:0px; margin: 0px 0px 0px 1em;}
        .block_motif {position:absolute; z-index:3; height:12px; top:0px; text-align:center; vertical-align:middle; background-color:cyan;}
        .block_rule {position:absolute; z-index:2; width:100%; height:1px; top:12px; left:0px; background-color:gray;}
        .block_plus_sym {position:absolute; z-index:4; line-height:12px; top:0px; left:-1em;}
        .block_minus_sym {position:absolute; z-index:4; line-height:12px; top:13px; left:-1em;}

        .tic_major {position:absolute; border-left:2px solid blue; height:0.5em; top:0em;}
        .tic_minor {position:absolute; border-left:1px solid blue; height:0.2em; top:0em;}
        .tic_label {position:absolute; top:0.5em;  height: 1em; text-align:center; vertical-align:middle}

        .explain h5 {font-size:1em; margin-left: 1em;}

        div.doc {margin-left: 2em; margin-bottom: 3em;}
        
        div.tabArea {
          font-size: 80%;
          font-weight: bold;
        }

        a.tab {
          background-color: #ddddff;
          border: 1px solid #000000;
          padding: 2px 1em 2px 1em;
          text-decoration: none;
        }
        div.tabArea.base a.tab {
          border-top-width: 0px;
        }
        div.tabArea.top a.tab {
          border-bottom-width: 0px;
        }

        a.tab, a.tab:visited {
          color: #808080;
        }

        a.tab:hover {
          background-color: #d0d0d0;
          color: #606060;
        }
        a.tab.activeTab, a.tab.activeTab:hover, a.tab.activeTab:visited {
          background-color: #f0f0f0;
          color: #000000;
        }
        div.tabMain {
          border: 1px solid #000000;
          background-color: #ffffff;
          padding: 5px;
          margin-right: 5px;
        }
        th.trainingset {
          border-bottom: thin dashed black; 
          font-weight:normal; 
          padding:0px 10px;
        }
        .dnaseq {
          font-weight: bold; 
          font-size: large; 
          font-family: 'Courier New', Courier, monospace;
        }
        .dna_A {
          color: rgb(204,0,0);
        }
        .dna_C {
          color: rgb(0,0,204);
        }
        .dna_G {
          color: rgb(255,179,0);
        }
        .dna_T {
          color: rgb(0,128,0);
        }

    </style>
  </head>
  <body onload="page_loaded()" onpageshow="page_shown(event)">
    <!-- Popups -->
    <div id="logo_popup" class="pop_logo">
      <canvas id="logo_popup_canvas" width="200" height="50"></canvas>
      <canvas id="logo_popup_canvas_rc" width="200" height="50"></canvas>
    </div>
    <!-- Help popups -->
    <div class="pop_content" id="pop_prob_graph">
      <p>Each "site-probability" graph shows the probability of the
      <b>best</b> site of a given motif occuring at a given position in the
      input sequences.  This probability is based only on sequences that
      contain at least one site with score greater than the score threshold 
      (<script>document.write(data['options']['score'])</script> bits).</p>
      <p>Points (X,Y) on the plot are:<br>
      &nbsp;&nbsp;Y = Pr(best site occurs at position X | sequence contains a site)</p>
      <p><b>Note:</b> The plots are smoothed according to the function 
      selected from the "Smoothing" menu on the right. Setting the smoothing
      window size to 1 turns off smoothing.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_plotting">
      <p>This shows a listing of all motifs currently plotted on the graph.</p>
      <p>The color used to plot a motif can be changed by clicking on the
      color swatch next to the motif you want to change, followed by clicking
      on the color swatch you wish to swap it with.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_unused_colours">
      <p>These are extra colors you may use for plotting motifs.</p>  
      <p>Click on the color swatch next to one of the above motifs, then click 
      on one of these "unused color" swatches to change the color of the 
      motif's plot.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" style="width: 500px" id="pop_graph">
      <p>These options change the display of the graph.</p>
      <dl>
        <dt>Smoothing:</dt>
        <dd><p>Allows selection of the smoothing function applied to the graph.</p>
        <p>The weighted moving average option uses weights shaped as an isosceles 
        triangle where the central point (or points in an even sized window) 
        get the maximum weight.</p>
        <p>The moving average simply weights all points in the smoothing window 
        equally.</p> 
        <p><b>Note:</b> Setting the smoothing window size to 1 turns off 
        smoothing.</dd></p>
        <dt>Window</dt>
        <dd><p>The window size used to smooth the graph. The larger the smoothing
        window size, the smoother the graph, at the cost of hiding detail.</p> 
        <p>Below a smoothing window size of 10, thinner lines are used on the 
        graph to allow more detail to be visible.</p>
        <p><b>Note:</b> Remember to press "return" or "enter" after changing 
        the number in the input box in order to see the effect of the new 
        smoothing window size.</p></dd>
        <dt>Legend</dt>
        <dd><p>Choose to display/disable the on-graph legend. The legend can be 
        moved by clicking on the graph.</p></dd>
        <dt>Download EPS</dt>
        <dd><p>Download the graph that you are currently viewing as an 
        encapsulated postscript (EPS) image. EPS images are scalable making them
        suitable for publication.</p></dd>
      </dl>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_filtering">
      <p>List only centrally enriched motifs that meet the selected filter criteria below.</p>
      <p><b>Selected motifs are always listed</b>; deselect all motifs first by clicking on
      the "X" above the color swatches if you wish to filter all motifs.</p>
      <p>To filter on "ID" or "Name", you can enter any Javascript regular
      expression pattern.  See <a href="http://www.w3schools.com/jsref/jsref_obj_regexp.asp">here</a>
      for documentation on Javascript regular expression patterns.</p>
      <div style="float:right; bottom:0px;">[
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_db">
      <p>The name of the database (file name) that contains the motif.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_id">
      <p>A name for the motif that is unique in the motif database file.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_name">
      <p>An alternate name of the motif that may be provided in the motif database file.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_pvalue">
      The probability that a <b>single random</b> motif would have any central bin
      as enriched for best matches as this combination of motif and bin width does.
      <p>The <i>p</i>-value is calculated by using the one-tailed binomial test on each
      possible centered bin width.  The test computes the probability of "bin sites"
      or more best sites falling in the central bin, given that "total sites" best sites
      fall somewhere, assuming a uniform null probability.  In other words,
      the probability that a given best site falls in the central bin
      is assumed to be the central bin width divided by the number of places 
      a motif can align in the sequence (sequence length minus motif width plus 1).
      The smallest <i>p</i>-value is then corrected to account for the number of bin widths tested.</p> 
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_evalue">
      <p>The expected number of <b>random</b> motifs that would have a central bin as enriched
      for best matches or better.  The <i>E</i>-value is the <i>p</i>-value
      multiplied by the number of motifs in the input database(s).</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_binw">
      <p>The width (in sequence positions) of the central region where the motif may match.  
      This is the width of the most enriched central bin (the one with the smallest <i>p</i>-value).
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_bin_sites">
      <p>The number of sequences where the <b>best</b> match to the motif falls in the central bin.</p>
      <p><b>Note:</b> This number may be less than the number of sequences that actually have a 
      match to the motif within the central bin because there may be a match outside of the 
      central bin with a larger score.  When there are ties for best match between sites inside
      and outside the central bin, one is selected at random.  This will also cause "bin sites"
      to be less than the actual number of sequences with a match within the central bin.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_total_sites">
      <p>The number of sequences containing a match to the motif above the given score threshold
      (<script>document.write(data['options']['score'])</script> bits).</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_prob">
      <p>The maximum probability observed for the best match occuring at any given position.
      If the window size on the graph is set to 1, then this is the height of the
      highest peak.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <!-- Page starts here -->
    <div id="top" class="pad1">
      <h1><img src="http://vm2.ucsd.edu:8080/meme/doc/images/centrimo_logo.png" alt="CentriMo" /></h1>
      <p>
        For further information on how to interpret these results or to get a 
        copy of the MEME software please access 
        <a href="http://meme.nbcr.net/">http://meme.nbcr.net</a>. 
      </p>
      <p>If you use CentriMo in your research, please cite the following paper:<br />
        <span class="citation">
          Timothy L. Bailey and Philip Machanick, 
          &quot;Inferring direct DNA binding from ChIP-seq&quot;, submitted.
        </span>
      </p>
    </div>
    <!-- navigation -->
    <div class="pad2">
      <a class="jump" href="#graph_sec">Motif Probability Graph</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#data_sec">Centrally Enriched Motifs</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#inputs">Input Files</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#info_sec">Program information</a>
    </div>
    <!-- alert the user when their browser is not up to the task -->
    <noscript><h1 style="color:red">Javascript is required to view these results!</h1></noscript>
    <script>
      if (!window.HTMLCanvasElement)
        document.write("<h1 style=\"color:red\">Your browser does not support canvas!</h1>\n");
    </script>
    <h2 class="mainh pad2">Results</h2>
    <div class="box">
      <!-- write out the job description -->
      <script>
        if (data['job_description']) {
          document.write('<h4 id="description">Description</h4>\n');
          var paragraphs = data['job_description'].split("\n\n");
          for (var i = 0; i < paragraphs.length; i++) {
            document.write('<p>');
            document.write(paragraphs[i].split("\n").join('<br>'));
            document.write('</p>\n');
          }
        }
      </script>
      <div>
        <div style="float:left; width:70%">
          <h4 id="graph_sec">Motif Probability Graph (score &ge; 
            <script>document.write(data['options']['score']);</script> 
            bits)&nbsp;<div class="help" onclick="help_popup(this, 'pop_prob_graph')"></div></h4>
          <canvas id="graph" width="700" height="400" onclick="move_legend(event)"></canvas>
        </div>
        <div class="graph_options_section">
          <h4 id="graph_sec">Options</h4>
          <h5>Plotting&nbsp;<div class="help" onclick="help_popup(this, 'pop_plotting')"></div></h5>
          <div style="max-height:200px; min-height:100px; overflow-y: auto;">
            <table class="graph_list" id="graph_list"><tbody></tbody></table>
          </div>
          <div id="unused_colours_section">
            <h5>Unused Colours&nbsp;<div class="help" onclick="help_popup(this, 'pop_unused_colours')"></div></h5>
            <span id="unused_colours"></span>
          </div>
          <h5>Graph&nbsp;<div class="help" onclick="help_popup(this, 'pop_graph')"></div></h5>
          <div>
            <label for="plot_type">Smoothing:</label>
            <select id="plot_type" onchange="make_MP_graph()">
              <option value="0">Moving Average</option>
              <option value="1" selected>Weighted Moving Average</option>
            </select>
          </div>
          <div>
            <label for="windo">Window:</label>
            <input type="number" style="min-width:40px;" id="windo" 
            onkeypress="num_keys(event)"
            onchange="make_MP_graph()" value="20" size="2" min="1">
          </div>
          <div>
            <label for="legend">Legend:</label>
            <select id="legend" onchange="make_MP_graph()">
              <option value="0">Disabled</option>
              <option value="1" selected>Enabled (click on graph to move)</option>
            </select>
          </div>
          <div style="margin-top:10px;"> 
            <script>
              document.write("<form method='post' action='" + site_url + "/cgi-bin/echo.cgi'>");
            </script>
              <input type="hidden" name="name" value="centrimo.eps">
              <input type="hidden" name="mime_type" value="application/postscript">
              <input type="hidden" id="eps_content" name="content" value="">
              <input type="submit" onclick="download_eps()" value="Download EPS (for publication)">
            </form>
          </div>
        </div>
      </div>
      <div>
        <div style="float:left; width:70%">
          <h4 id="data_sec">Centrally Enriched Motifs</h4>
          <table class="motifs hide_db hide_maxprob hide_tsites" id="motifs">
            <thead>
            <tr>
              <th class="deselect" onclick="clear_selection()" 
                title="clear selection">&#x2612;</th>
              <th class="col_db">Database&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_db')"></div></th>
              <th>ID&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_id')"></div></th>
              <th class="col_name">Name&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_name')"></div></th>
              <th><i>E</i>-value&nbsp;<div class="help" 
                    onclick="help_popup(this, 'pop_evalue')"></div></th>
              <th class="col_pvalue"><i>p</i>-value&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_pvalue')"></div></th>
              <th>Bin Width&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_binw')"></div></th>
              <th class="col_bsites">Bin Sites&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_bin_sites')"></div></th>
              <th class="col_tsites">Total Sites&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_total_sites')"></div></th>
              <th class="col_maxprob">Max Probability&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_prob')"></div></th>
            </tr>
            </thead>
            <tbody>
            </tbody>
          </table>
        </div>
        <div style="float:right; width:30%">
          <h4>Sort &amp; Filter</h4>
          <div style="margin-top:10px;">
            <h5>Sort</h5>
            <label for="sort">Column: </label>
            <select id="sort">
              <option value="0">ID</option>
              <option value="1">Name</option>
              <option value="2" selected><i>E</i>-value (also <i>p</i>-value)</option>
              <option value="3">Bin Width</option>
              <option value="4">Bin Sites</option>
              <option value="5">Total Sites</option>
              <option value="6">Max Probability</option>
            </select>
          </div>
          <h5>Filters&nbsp;<div style="margin-top:5px;" class="help" 
              onclick="help_popup(this, 'pop_filtering')" ></div></h5>
          <div id="filters">
            <div >
              <input type="checkbox" id="filter_on_top" value="1" 
              onclick="toggle_filter(this, 'filter_top')">
              <label for="filter_top" 
                onclick="enable_filter('filter_on_top', 'filter_top')">Top</label>
              <input type="number" id="filter_top" value="10" size="4" min="1"
              onkeypress="num_keys(event); update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_db" value="1" 
              onclick="toggle_filter(this, 'filter_db')">
              <label for="filter_db" 
                onclick="enable_filter('filter_on_db', 'filter_db')"
                >Database is</label>
              <select id="filter_db" disabled>
                <script>
                  for (var i = 0; i < data['motif_dbs'].length; i++) {
                    var db = data['motif_dbs'][i];
                    document.write("<option value=\"" + i + "\">" + 
                        db['name'] + "</option>\n");
                  }
                </script> 
              </select>
            </div>
            <div >
              <input type="checkbox" id="filter_on_id" value="1" 
              onclick="toggle_filter(this, 'filter_id')">
              <label for="filter_id" 
                onclick="enable_filter('filter_on_id', 'filter_id')"
                >ID matches</label>
              <input type="text" id="filter_id" value=".*" size="12" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_alt" value="1" 
              onclick="toggle_filter(this, 'filter_alt')">
              <label for="filter_alt"
                onclick="enable_filter('filter_on_alt', 'filter_alt')"
                >Name matches</label>
              <input type="text" id="filter_alt" value=".*" size="12" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_evalue" value="1" 
              onclick="toggle_filter(this, 'filter_evalue')">
              <label for="filter_evalue"
                onclick="enable_filter('filter_on_evalue', 'filter_evalue')"
                >Evalue &le;</label>
              <input type="text" id="filter_evalue" value="1" size="7" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_binwidth" value="1" 
              onclick="toggle_filter(this, 'filter_binwidth')">
              <label for="filter_binwidth"
                onclick="enable_filter('filter_on_binwidth', 'filter_binwidth')"
                >Bin Width &le;</label>
              <input type="number" id="filter_binwidth" value="200" size="7" 
              min="1" onkeypress="num_keys(event); update_filter(event)" disabled>
            </div>
          </div>
          <div>
            <input type="button" value="Update" onclick="make_CEM_table()">
          </div>
          <h4>Optional Columns</h4>
          <div >
            <input type="checkbox" id="show_db" value="1" 
            onclick="toggle_column('hide_db')">
            <label for="show_db">Show Database</label>
          </div>
          <div >
            <input type="checkbox" id="show_name" value="1" 
            onclick="toggle_column('hide_name')" checked>
            <label for="show_name">Show Name</label>
          </div>
          <div >
            <input type="checkbox" id="show_pvalue" value="1" 
            onclick="toggle_column('hide_pvalue')" checked>
            <label for="show_pvalue">Show <i>p</i>-value</label>
          </div>
          <div >
            <input type="checkbox" id="show_bsites" value="1" 
            onclick="toggle_column('hide_bsites')" checked>
            <label for="show_bsites">Show Bin Sites</label>
          </div>
          <div >
            <input type="checkbox" id="show_tsites" value="1" 
            onclick="toggle_column('hide_tsites')">
            <label for="show_tsites">Show Total Sites</label>
          </div>
          <div >
            <input type="checkbox" id="show_maxprob" value="1" 
            onclick="toggle_column('hide_maxprob')">
            <label for="show_maxprob">Show Max Probability</label>
          </div>
        </div>
        <div style="clear:both"></div>
      </div>
    </div>
    <h2 id="inputs" class="mainh pad2">Input Files</h2>
    <div class="box">
      <h4>Sequences</h4>
      <table class="inputs">
        <tr><th>Database</th><th>Source</th><th>Sequence Count</th></tr>
        <tr>
          <script>
          {
            var db = data['sequence_db'];
            document.write("<td>"  + db['name'] + "</td>");
            document.write("<td>" + db['source'] + "</td>");
            document.write("<td>" + db['count'] + "</td>");
          }
          </script>
        </tr>
      </table>
      <h4>Motifs</h4>
      <table class="inputs">
        <tr><th>Database</th><th>Source</th><th>Motif Count</th></tr>
        <script>
        {
          var motif_dbs = data['motif_dbs'];
          for (var i = 0; i < motif_dbs.length; i++) {
            var db = motif_dbs[i];
            document.write("<tr>");
            document.write("<td>"  + db['name'] + "</td>");
            document.write("<td>" + db['source'] + "</td>");
            document.write("<td>" + db['count'] + "</td>");
            document.write("</tr>");
          }
        }
        </script>
      </table>
    </div>
    <div id="info_sec" class="bar">
      <div class="subsection">
        <a name="version"/>
        <h5>CentriMo version</h5>
        <script>document.write(data["version"]);</script> 
        (Release date: <script>document.write(data["release"]);</script>)
      </div>
      <div class="subsection">
        <a name="reference"/>
        <h5>Reference</h5>
        <span class="citation">
          Timothy L. Bailey and Philip Machanick, 
          &quot;Inferring direct DNA binding from ChIP-seq&quot;, submitted.
        </span>
        <div class="subsection">
          <a name="command" />
          <h5>Command line summary</h5>
          <textarea id="cmd" rows="1" style="width:100%;" readonly="readonly">
          </textarea>
          <script>$("cmd").value = data["cmd"].join(" ");</script>
        </div>
      </div>
    </div>
  </body>
</html>
